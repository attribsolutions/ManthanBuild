{"ast":null,"code":"'use strict';\n\nvar Registry = require('../registry');\n\nvar Lib = require('../lib');\n/*\n * Create or update an observer. This function is designed to be\n * idempotent so that it can be called over and over as the component\n * updates, and will attach and detach listeners as needed.\n *\n * @param {optional object} container\n *      An object on which the observer is stored. This is the mechanism\n *      by which it is idempotent. If it already exists, another won't be\n *      added. Each time it's called, the value lookup table is updated.\n * @param {array} commandList\n *      An array of commands, following either `buttons` of `updatemenus`\n *      or `steps` of `sliders`.\n * @param {function} onchange\n *      A listener called when the value is changed. Receives data object\n *      with information about the new state.\n */\n\n\nexports.manageCommandObserver = function (gd, container, commandList, onchange) {\n  var ret = {};\n  var enabled = true;\n\n  if (container && container._commandObserver) {\n    ret = container._commandObserver;\n  }\n\n  if (!ret.cache) {\n    ret.cache = {};\n  } // Either create or just recompute this:\n\n\n  ret.lookupTable = {};\n  var binding = exports.hasSimpleAPICommandBindings(gd, commandList, ret.lookupTable);\n\n  if (container && container._commandObserver) {\n    if (!binding) {\n      // If container exists and there are no longer any bindings,\n      // remove existing:\n      if (container._commandObserver.remove) {\n        container._commandObserver.remove();\n\n        container._commandObserver = null;\n        return ret;\n      }\n    } else {\n      // If container exists and there *are* bindings, then the lookup\n      // table should have been updated and check is already attached,\n      // so there's nothing to be done:\n      return ret;\n    }\n  } // Determine whether there's anything to do for this binding:\n\n\n  if (binding) {\n    // Build the cache:\n    bindingValueHasChanged(gd, binding, ret.cache);\n\n    ret.check = function check() {\n      if (!enabled) return;\n      var update = bindingValueHasChanged(gd, binding, ret.cache);\n\n      if (update.changed && onchange) {\n        // Disable checks for the duration of this command in order to avoid\n        // infinite loops:\n        if (ret.lookupTable[update.value] !== undefined) {\n          ret.disable();\n          Promise.resolve(onchange({\n            value: update.value,\n            type: binding.type,\n            prop: binding.prop,\n            traces: binding.traces,\n            index: ret.lookupTable[update.value]\n          })).then(ret.enable, ret.enable);\n        }\n      }\n\n      return update.changed;\n    };\n\n    var checkEvents = ['plotly_relayout', 'plotly_redraw', 'plotly_restyle', 'plotly_update', 'plotly_animatingframe', 'plotly_afterplot'];\n\n    for (var i = 0; i < checkEvents.length; i++) {\n      gd._internalOn(checkEvents[i], ret.check);\n    }\n\n    ret.remove = function () {\n      for (var i = 0; i < checkEvents.length; i++) {\n        gd._removeInternalListener(checkEvents[i], ret.check);\n      }\n    };\n  } else {\n    // TODO: It'd be really neat to actually give a *reason* for this, but at least a warning\n    // is a start\n    Lib.log('Unable to automatically bind plot updates to API command');\n    ret.lookupTable = {};\n\n    ret.remove = function () {};\n  }\n\n  ret.disable = function disable() {\n    enabled = false;\n  };\n\n  ret.enable = function enable() {\n    enabled = true;\n  };\n\n  if (container) {\n    container._commandObserver = ret;\n  }\n\n  return ret;\n};\n/*\n * This function checks to see if an array of objects containing\n * method and args properties is compatible with automatic two-way\n * binding. The criteria right now are that\n *\n *   1. multiple traces may be affected\n *   2. only one property may be affected\n *   3. the same property must be affected by all commands\n */\n\n\nexports.hasSimpleAPICommandBindings = function (gd, commandList, bindingsByValue) {\n  var i;\n  var n = commandList.length;\n  var refBinding;\n\n  for (i = 0; i < n; i++) {\n    var binding;\n    var command = commandList[i];\n    var method = command.method;\n    var args = command.args;\n    if (!Array.isArray(args)) args = []; // If any command has no method, refuse to bind:\n\n    if (!method) {\n      return false;\n    }\n\n    var bindings = exports.computeAPICommandBindings(gd, method, args); // Right now, handle one and *only* one property being set:\n\n    if (bindings.length !== 1) {\n      return false;\n    }\n\n    if (!refBinding) {\n      refBinding = bindings[0];\n\n      if (Array.isArray(refBinding.traces)) {\n        refBinding.traces.sort();\n      }\n    } else {\n      binding = bindings[0];\n\n      if (binding.type !== refBinding.type) {\n        return false;\n      }\n\n      if (binding.prop !== refBinding.prop) {\n        return false;\n      }\n\n      if (Array.isArray(refBinding.traces)) {\n        if (Array.isArray(binding.traces)) {\n          binding.traces.sort();\n\n          for (var j = 0; j < refBinding.traces.length; j++) {\n            if (refBinding.traces[j] !== binding.traces[j]) {\n              return false;\n            }\n          }\n        } else {\n          return false;\n        }\n      } else {\n        if (binding.prop !== refBinding.prop) {\n          return false;\n        }\n      }\n    }\n\n    binding = bindings[0];\n    var value = binding.value;\n\n    if (Array.isArray(value)) {\n      if (value.length === 1) {\n        value = value[0];\n      } else {\n        return false;\n      }\n    }\n\n    if (bindingsByValue) {\n      bindingsByValue[value] = i;\n    }\n  }\n\n  return refBinding;\n};\n\nfunction bindingValueHasChanged(gd, binding, cache) {\n  var container, value, obj;\n  var changed = false;\n\n  if (binding.type === 'data') {\n    // If it's data, we need to get a trace. Based on the limited scope\n    // of what we cover, we can just take the first trace from the list,\n    // or otherwise just the first trace:\n    container = gd._fullData[binding.traces !== null ? binding.traces[0] : 0];\n  } else if (binding.type === 'layout') {\n    container = gd._fullLayout;\n  } else {\n    return false;\n  }\n\n  value = Lib.nestedProperty(container, binding.prop).get();\n  obj = cache[binding.type] = cache[binding.type] || {};\n\n  if (obj.hasOwnProperty(binding.prop)) {\n    if (obj[binding.prop] !== value) {\n      changed = true;\n    }\n  }\n\n  obj[binding.prop] = value;\n  return {\n    changed: changed,\n    value: value\n  };\n}\n/*\n * Execute an API command. There's really not much to this; it just provides\n * a common hook so that implementations don't need to be synchronized across\n * multiple components with the ability to invoke API commands.\n *\n * @param {string} method\n *      The name of the plotly command to execute. Must be one of 'animate',\n *      'restyle', 'relayout', 'update'.\n * @param {array} args\n *      A list of arguments passed to the API command\n */\n\n\nexports.executeAPICommand = function (gd, method, args) {\n  if (method === 'skip') return Promise.resolve();\n  var _method = Registry.apiMethodRegistry[method];\n  var allArgs = [gd];\n  if (!Array.isArray(args)) args = [];\n\n  for (var i = 0; i < args.length; i++) {\n    allArgs.push(args[i]);\n  }\n\n  return _method.apply(null, allArgs).catch(function (err) {\n    Lib.warn('API call to Plotly.' + method + ' rejected.', err);\n    return Promise.reject(err);\n  });\n};\n\nexports.computeAPICommandBindings = function (gd, method, args) {\n  var bindings;\n  if (!Array.isArray(args)) args = [];\n\n  switch (method) {\n    case 'restyle':\n      bindings = computeDataBindings(gd, args);\n      break;\n\n    case 'relayout':\n      bindings = computeLayoutBindings(gd, args);\n      break;\n\n    case 'update':\n      bindings = computeDataBindings(gd, [args[0], args[2]]).concat(computeLayoutBindings(gd, [args[1]]));\n      break;\n\n    case 'animate':\n      bindings = computeAnimateBindings(gd, args);\n      break;\n\n    default:\n      // This is the case where intelligent logic about what affects\n      // this command is not implemented. It causes no ill effects.\n      // For example, addFrames simply won't bind to a control component.\n      bindings = [];\n  }\n\n  return bindings;\n};\n\nfunction computeAnimateBindings(gd, args) {\n  // We'll assume that the only relevant modification an animation\n  // makes that's meaningfully tracked is the frame:\n  if (Array.isArray(args[0]) && args[0].length === 1 && ['string', 'number'].indexOf(typeof args[0][0]) !== -1) {\n    return [{\n      type: 'layout',\n      prop: '_currentFrame',\n      value: args[0][0].toString()\n    }];\n  } else {\n    return [];\n  }\n}\n\nfunction computeLayoutBindings(gd, args) {\n  var bindings = [];\n  var astr = args[0];\n  var aobj = {};\n\n  if (typeof astr === 'string') {\n    aobj[astr] = args[1];\n  } else if (Lib.isPlainObject(astr)) {\n    aobj = astr;\n  } else {\n    return bindings;\n  }\n\n  crawl(aobj, function (path, attrName, attr) {\n    bindings.push({\n      type: 'layout',\n      prop: path,\n      value: attr\n    });\n  }, '', 0);\n  return bindings;\n}\n\nfunction computeDataBindings(gd, args) {\n  var traces, astr, val, aobj;\n  var bindings = []; // Logic copied from Plotly.restyle:\n\n  astr = args[0];\n  val = args[1];\n  traces = args[2];\n  aobj = {};\n\n  if (typeof astr === 'string') {\n    aobj[astr] = val;\n  } else if (Lib.isPlainObject(astr)) {\n    // the 3-arg form\n    aobj = astr;\n\n    if (traces === undefined) {\n      traces = val;\n    }\n  } else {\n    return bindings;\n  }\n\n  if (traces === undefined) {\n    // Explicitly assign this to null instead of undefined:\n    traces = null;\n  }\n\n  crawl(aobj, function (path, attrName, _attr) {\n    var thisTraces;\n    var attr;\n\n    if (Array.isArray(_attr)) {\n      attr = _attr.slice();\n      var nAttr = Math.min(attr.length, gd.data.length);\n\n      if (traces) {\n        nAttr = Math.min(nAttr, traces.length);\n      }\n\n      thisTraces = [];\n\n      for (var j = 0; j < nAttr; j++) {\n        thisTraces[j] = traces ? traces[j] : j;\n      }\n    } else {\n      attr = _attr;\n      thisTraces = traces ? traces.slice() : null;\n    } // Convert [7] to just 7 when traces is null:\n\n\n    if (thisTraces === null) {\n      if (Array.isArray(attr)) {\n        attr = attr[0];\n      }\n    } else if (Array.isArray(thisTraces)) {\n      if (!Array.isArray(attr)) {\n        var tmp = attr;\n        attr = [];\n\n        for (var i = 0; i < thisTraces.length; i++) {\n          attr[i] = tmp;\n        }\n      }\n\n      attr.length = Math.min(thisTraces.length, attr.length);\n    }\n\n    bindings.push({\n      type: 'data',\n      prop: path,\n      traces: thisTraces,\n      value: attr\n    });\n  }, '', 0);\n  return bindings;\n}\n\nfunction crawl(attrs, callback, path, depth) {\n  Object.keys(attrs).forEach(function (attrName) {\n    var attr = attrs[attrName];\n    if (attrName[0] === '_') return;\n    var thisPath = path + (depth > 0 ? '.' : '') + attrName;\n\n    if (Lib.isPlainObject(attr)) {\n      crawl(attr, callback, thisPath, depth + 1);\n    } else {\n      // Only execute the callback on leaf nodes:\n      callback(thisPath, attrName, attr);\n    }\n  });\n}","map":{"version":3,"names":["Registry","require","Lib","exports","manageCommandObserver","gd","container","commandList","onchange","ret","enabled","_commandObserver","cache","lookupTable","binding","hasSimpleAPICommandBindings","remove","bindingValueHasChanged","check","update","changed","value","undefined","disable","Promise","resolve","type","prop","traces","index","then","enable","checkEvents","i","length","_internalOn","_removeInternalListener","log","bindingsByValue","n","refBinding","command","method","args","Array","isArray","bindings","computeAPICommandBindings","sort","j","obj","_fullData","_fullLayout","nestedProperty","get","hasOwnProperty","executeAPICommand","_method","apiMethodRegistry","allArgs","push","apply","catch","err","warn","reject","computeDataBindings","computeLayoutBindings","concat","computeAnimateBindings","indexOf","toString","astr","aobj","isPlainObject","crawl","path","attrName","attr","val","_attr","thisTraces","slice","nAttr","Math","min","data","tmp","attrs","callback","depth","Object","keys","forEach","thisPath"],"sources":["D:/Rohit/Git projects/Manthan/node_modules/plotly.js/src/plots/command.js"],"sourcesContent":["'use strict';\n\nvar Registry = require('../registry');\nvar Lib = require('../lib');\n\n/*\n * Create or update an observer. This function is designed to be\n * idempotent so that it can be called over and over as the component\n * updates, and will attach and detach listeners as needed.\n *\n * @param {optional object} container\n *      An object on which the observer is stored. This is the mechanism\n *      by which it is idempotent. If it already exists, another won't be\n *      added. Each time it's called, the value lookup table is updated.\n * @param {array} commandList\n *      An array of commands, following either `buttons` of `updatemenus`\n *      or `steps` of `sliders`.\n * @param {function} onchange\n *      A listener called when the value is changed. Receives data object\n *      with information about the new state.\n */\nexports.manageCommandObserver = function(gd, container, commandList, onchange) {\n    var ret = {};\n    var enabled = true;\n\n    if(container && container._commandObserver) {\n        ret = container._commandObserver;\n    }\n\n    if(!ret.cache) {\n        ret.cache = {};\n    }\n\n    // Either create or just recompute this:\n    ret.lookupTable = {};\n\n    var binding = exports.hasSimpleAPICommandBindings(gd, commandList, ret.lookupTable);\n\n    if(container && container._commandObserver) {\n        if(!binding) {\n            // If container exists and there are no longer any bindings,\n            // remove existing:\n            if(container._commandObserver.remove) {\n                container._commandObserver.remove();\n                container._commandObserver = null;\n                return ret;\n            }\n        } else {\n            // If container exists and there *are* bindings, then the lookup\n            // table should have been updated and check is already attached,\n            // so there's nothing to be done:\n            return ret;\n        }\n    }\n\n    // Determine whether there's anything to do for this binding:\n\n    if(binding) {\n        // Build the cache:\n        bindingValueHasChanged(gd, binding, ret.cache);\n\n        ret.check = function check() {\n            if(!enabled) return;\n\n            var update = bindingValueHasChanged(gd, binding, ret.cache);\n\n            if(update.changed && onchange) {\n                // Disable checks for the duration of this command in order to avoid\n                // infinite loops:\n                if(ret.lookupTable[update.value] !== undefined) {\n                    ret.disable();\n                    Promise.resolve(onchange({\n                        value: update.value,\n                        type: binding.type,\n                        prop: binding.prop,\n                        traces: binding.traces,\n                        index: ret.lookupTable[update.value]\n                    })).then(ret.enable, ret.enable);\n                }\n            }\n\n            return update.changed;\n        };\n\n        var checkEvents = [\n            'plotly_relayout',\n            'plotly_redraw',\n            'plotly_restyle',\n            'plotly_update',\n            'plotly_animatingframe',\n            'plotly_afterplot'\n        ];\n\n        for(var i = 0; i < checkEvents.length; i++) {\n            gd._internalOn(checkEvents[i], ret.check);\n        }\n\n        ret.remove = function() {\n            for(var i = 0; i < checkEvents.length; i++) {\n                gd._removeInternalListener(checkEvents[i], ret.check);\n            }\n        };\n    } else {\n        // TODO: It'd be really neat to actually give a *reason* for this, but at least a warning\n        // is a start\n        Lib.log('Unable to automatically bind plot updates to API command');\n\n        ret.lookupTable = {};\n        ret.remove = function() {};\n    }\n\n    ret.disable = function disable() {\n        enabled = false;\n    };\n\n    ret.enable = function enable() {\n        enabled = true;\n    };\n\n    if(container) {\n        container._commandObserver = ret;\n    }\n\n    return ret;\n};\n\n/*\n * This function checks to see if an array of objects containing\n * method and args properties is compatible with automatic two-way\n * binding. The criteria right now are that\n *\n *   1. multiple traces may be affected\n *   2. only one property may be affected\n *   3. the same property must be affected by all commands\n */\nexports.hasSimpleAPICommandBindings = function(gd, commandList, bindingsByValue) {\n    var i;\n    var n = commandList.length;\n\n    var refBinding;\n\n    for(i = 0; i < n; i++) {\n        var binding;\n        var command = commandList[i];\n        var method = command.method;\n        var args = command.args;\n\n        if(!Array.isArray(args)) args = [];\n\n        // If any command has no method, refuse to bind:\n        if(!method) {\n            return false;\n        }\n        var bindings = exports.computeAPICommandBindings(gd, method, args);\n\n        // Right now, handle one and *only* one property being set:\n        if(bindings.length !== 1) {\n            return false;\n        }\n\n        if(!refBinding) {\n            refBinding = bindings[0];\n            if(Array.isArray(refBinding.traces)) {\n                refBinding.traces.sort();\n            }\n        } else {\n            binding = bindings[0];\n            if(binding.type !== refBinding.type) {\n                return false;\n            }\n            if(binding.prop !== refBinding.prop) {\n                return false;\n            }\n            if(Array.isArray(refBinding.traces)) {\n                if(Array.isArray(binding.traces)) {\n                    binding.traces.sort();\n                    for(var j = 0; j < refBinding.traces.length; j++) {\n                        if(refBinding.traces[j] !== binding.traces[j]) {\n                            return false;\n                        }\n                    }\n                } else {\n                    return false;\n                }\n            } else {\n                if(binding.prop !== refBinding.prop) {\n                    return false;\n                }\n            }\n        }\n\n        binding = bindings[0];\n        var value = binding.value;\n        if(Array.isArray(value)) {\n            if(value.length === 1) {\n                value = value[0];\n            } else {\n                return false;\n            }\n        }\n        if(bindingsByValue) {\n            bindingsByValue[value] = i;\n        }\n    }\n\n    return refBinding;\n};\n\nfunction bindingValueHasChanged(gd, binding, cache) {\n    var container, value, obj;\n    var changed = false;\n\n    if(binding.type === 'data') {\n        // If it's data, we need to get a trace. Based on the limited scope\n        // of what we cover, we can just take the first trace from the list,\n        // or otherwise just the first trace:\n        container = gd._fullData[binding.traces !== null ? binding.traces[0] : 0];\n    } else if(binding.type === 'layout') {\n        container = gd._fullLayout;\n    } else {\n        return false;\n    }\n\n    value = Lib.nestedProperty(container, binding.prop).get();\n\n    obj = cache[binding.type] = cache[binding.type] || {};\n\n    if(obj.hasOwnProperty(binding.prop)) {\n        if(obj[binding.prop] !== value) {\n            changed = true;\n        }\n    }\n\n    obj[binding.prop] = value;\n\n    return {\n        changed: changed,\n        value: value\n    };\n}\n\n/*\n * Execute an API command. There's really not much to this; it just provides\n * a common hook so that implementations don't need to be synchronized across\n * multiple components with the ability to invoke API commands.\n *\n * @param {string} method\n *      The name of the plotly command to execute. Must be one of 'animate',\n *      'restyle', 'relayout', 'update'.\n * @param {array} args\n *      A list of arguments passed to the API command\n */\nexports.executeAPICommand = function(gd, method, args) {\n    if(method === 'skip') return Promise.resolve();\n\n    var _method = Registry.apiMethodRegistry[method];\n    var allArgs = [gd];\n    if(!Array.isArray(args)) args = [];\n\n    for(var i = 0; i < args.length; i++) {\n        allArgs.push(args[i]);\n    }\n\n    return _method.apply(null, allArgs).catch(function(err) {\n        Lib.warn('API call to Plotly.' + method + ' rejected.', err);\n        return Promise.reject(err);\n    });\n};\n\nexports.computeAPICommandBindings = function(gd, method, args) {\n    var bindings;\n\n    if(!Array.isArray(args)) args = [];\n\n    switch(method) {\n        case 'restyle':\n            bindings = computeDataBindings(gd, args);\n            break;\n        case 'relayout':\n            bindings = computeLayoutBindings(gd, args);\n            break;\n        case 'update':\n            bindings = computeDataBindings(gd, [args[0], args[2]])\n                .concat(computeLayoutBindings(gd, [args[1]]));\n            break;\n        case 'animate':\n            bindings = computeAnimateBindings(gd, args);\n            break;\n        default:\n            // This is the case where intelligent logic about what affects\n            // this command is not implemented. It causes no ill effects.\n            // For example, addFrames simply won't bind to a control component.\n            bindings = [];\n    }\n    return bindings;\n};\n\nfunction computeAnimateBindings(gd, args) {\n    // We'll assume that the only relevant modification an animation\n    // makes that's meaningfully tracked is the frame:\n    if(Array.isArray(args[0]) && args[0].length === 1 && ['string', 'number'].indexOf(typeof args[0][0]) !== -1) {\n        return [{type: 'layout', prop: '_currentFrame', value: args[0][0].toString()}];\n    } else {\n        return [];\n    }\n}\n\nfunction computeLayoutBindings(gd, args) {\n    var bindings = [];\n\n    var astr = args[0];\n    var aobj = {};\n    if(typeof astr === 'string') {\n        aobj[astr] = args[1];\n    } else if(Lib.isPlainObject(astr)) {\n        aobj = astr;\n    } else {\n        return bindings;\n    }\n\n    crawl(aobj, function(path, attrName, attr) {\n        bindings.push({type: 'layout', prop: path, value: attr});\n    }, '', 0);\n\n    return bindings;\n}\n\nfunction computeDataBindings(gd, args) {\n    var traces, astr, val, aobj;\n    var bindings = [];\n\n    // Logic copied from Plotly.restyle:\n    astr = args[0];\n    val = args[1];\n    traces = args[2];\n    aobj = {};\n    if(typeof astr === 'string') {\n        aobj[astr] = val;\n    } else if(Lib.isPlainObject(astr)) {\n        // the 3-arg form\n        aobj = astr;\n\n        if(traces === undefined) {\n            traces = val;\n        }\n    } else {\n        return bindings;\n    }\n\n    if(traces === undefined) {\n        // Explicitly assign this to null instead of undefined:\n        traces = null;\n    }\n\n    crawl(aobj, function(path, attrName, _attr) {\n        var thisTraces;\n        var attr;\n\n        if(Array.isArray(_attr)) {\n            attr = _attr.slice();\n\n            var nAttr = Math.min(attr.length, gd.data.length);\n            if(traces) {\n                nAttr = Math.min(nAttr, traces.length);\n            }\n            thisTraces = [];\n            for(var j = 0; j < nAttr; j++) {\n                thisTraces[j] = traces ? traces[j] : j;\n            }\n        } else {\n            attr = _attr;\n            thisTraces = traces ? traces.slice() : null;\n        }\n\n        // Convert [7] to just 7 when traces is null:\n        if(thisTraces === null) {\n            if(Array.isArray(attr)) {\n                attr = attr[0];\n            }\n        } else if(Array.isArray(thisTraces)) {\n            if(!Array.isArray(attr)) {\n                var tmp = attr;\n                attr = [];\n                for(var i = 0; i < thisTraces.length; i++) {\n                    attr[i] = tmp;\n                }\n            }\n            attr.length = Math.min(thisTraces.length, attr.length);\n        }\n\n        bindings.push({\n            type: 'data',\n            prop: path,\n            traces: thisTraces,\n            value: attr\n        });\n    }, '', 0);\n\n    return bindings;\n}\n\nfunction crawl(attrs, callback, path, depth) {\n    Object.keys(attrs).forEach(function(attrName) {\n        var attr = attrs[attrName];\n\n        if(attrName[0] === '_') return;\n\n        var thisPath = path + (depth > 0 ? '.' : '') + attrName;\n\n        if(Lib.isPlainObject(attr)) {\n            crawl(attr, callback, thisPath, depth + 1);\n        } else {\n            // Only execute the callback on leaf nodes:\n            callback(thisPath, attrName, attr);\n        }\n    });\n}\n"],"mappings":"AAAA;;AAEA,IAAIA,QAAQ,GAAGC,OAAO,CAAC,aAAD,CAAtB;;AACA,IAAIC,GAAG,GAAGD,OAAO,CAAC,QAAD,CAAjB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAE,OAAO,CAACC,qBAAR,GAAgC,UAASC,EAAT,EAAaC,SAAb,EAAwBC,WAAxB,EAAqCC,QAArC,EAA+C;EAC3E,IAAIC,GAAG,GAAG,EAAV;EACA,IAAIC,OAAO,GAAG,IAAd;;EAEA,IAAGJ,SAAS,IAAIA,SAAS,CAACK,gBAA1B,EAA4C;IACxCF,GAAG,GAAGH,SAAS,CAACK,gBAAhB;EACH;;EAED,IAAG,CAACF,GAAG,CAACG,KAAR,EAAe;IACXH,GAAG,CAACG,KAAJ,GAAY,EAAZ;EACH,CAV0E,CAY3E;;;EACAH,GAAG,CAACI,WAAJ,GAAkB,EAAlB;EAEA,IAAIC,OAAO,GAAGX,OAAO,CAACY,2BAAR,CAAoCV,EAApC,EAAwCE,WAAxC,EAAqDE,GAAG,CAACI,WAAzD,CAAd;;EAEA,IAAGP,SAAS,IAAIA,SAAS,CAACK,gBAA1B,EAA4C;IACxC,IAAG,CAACG,OAAJ,EAAa;MACT;MACA;MACA,IAAGR,SAAS,CAACK,gBAAV,CAA2BK,MAA9B,EAAsC;QAClCV,SAAS,CAACK,gBAAV,CAA2BK,MAA3B;;QACAV,SAAS,CAACK,gBAAV,GAA6B,IAA7B;QACA,OAAOF,GAAP;MACH;IACJ,CARD,MAQO;MACH;MACA;MACA;MACA,OAAOA,GAAP;IACH;EACJ,CAhC0E,CAkC3E;;;EAEA,IAAGK,OAAH,EAAY;IACR;IACAG,sBAAsB,CAACZ,EAAD,EAAKS,OAAL,EAAcL,GAAG,CAACG,KAAlB,CAAtB;;IAEAH,GAAG,CAACS,KAAJ,GAAY,SAASA,KAAT,GAAiB;MACzB,IAAG,CAACR,OAAJ,EAAa;MAEb,IAAIS,MAAM,GAAGF,sBAAsB,CAACZ,EAAD,EAAKS,OAAL,EAAcL,GAAG,CAACG,KAAlB,CAAnC;;MAEA,IAAGO,MAAM,CAACC,OAAP,IAAkBZ,QAArB,EAA+B;QAC3B;QACA;QACA,IAAGC,GAAG,CAACI,WAAJ,CAAgBM,MAAM,CAACE,KAAvB,MAAkCC,SAArC,EAAgD;UAC5Cb,GAAG,CAACc,OAAJ;UACAC,OAAO,CAACC,OAAR,CAAgBjB,QAAQ,CAAC;YACrBa,KAAK,EAAEF,MAAM,CAACE,KADO;YAErBK,IAAI,EAAEZ,OAAO,CAACY,IAFO;YAGrBC,IAAI,EAAEb,OAAO,CAACa,IAHO;YAIrBC,MAAM,EAAEd,OAAO,CAACc,MAJK;YAKrBC,KAAK,EAAEpB,GAAG,CAACI,WAAJ,CAAgBM,MAAM,CAACE,KAAvB;UALc,CAAD,CAAxB,EAMIS,IANJ,CAMSrB,GAAG,CAACsB,MANb,EAMqBtB,GAAG,CAACsB,MANzB;QAOH;MACJ;;MAED,OAAOZ,MAAM,CAACC,OAAd;IACH,CArBD;;IAuBA,IAAIY,WAAW,GAAG,CACd,iBADc,EAEd,eAFc,EAGd,gBAHc,EAId,eAJc,EAKd,uBALc,EAMd,kBANc,CAAlB;;IASA,KAAI,IAAIC,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAGD,WAAW,CAACE,MAA/B,EAAuCD,CAAC,EAAxC,EAA4C;MACxC5B,EAAE,CAAC8B,WAAH,CAAeH,WAAW,CAACC,CAAD,CAA1B,EAA+BxB,GAAG,CAACS,KAAnC;IACH;;IAEDT,GAAG,CAACO,MAAJ,GAAa,YAAW;MACpB,KAAI,IAAIiB,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAGD,WAAW,CAACE,MAA/B,EAAuCD,CAAC,EAAxC,EAA4C;QACxC5B,EAAE,CAAC+B,uBAAH,CAA2BJ,WAAW,CAACC,CAAD,CAAtC,EAA2CxB,GAAG,CAACS,KAA/C;MACH;IACJ,CAJD;EAKH,CA7CD,MA6CO;IACH;IACA;IACAhB,GAAG,CAACmC,GAAJ,CAAQ,0DAAR;IAEA5B,GAAG,CAACI,WAAJ,GAAkB,EAAlB;;IACAJ,GAAG,CAACO,MAAJ,GAAa,YAAW,CAAE,CAA1B;EACH;;EAEDP,GAAG,CAACc,OAAJ,GAAc,SAASA,OAAT,GAAmB;IAC7Bb,OAAO,GAAG,KAAV;EACH,CAFD;;EAIAD,GAAG,CAACsB,MAAJ,GAAa,SAASA,MAAT,GAAkB;IAC3BrB,OAAO,GAAG,IAAV;EACH,CAFD;;EAIA,IAAGJ,SAAH,EAAc;IACVA,SAAS,CAACK,gBAAV,GAA6BF,GAA7B;EACH;;EAED,OAAOA,GAAP;AACH,CAvGD;AAyGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAN,OAAO,CAACY,2BAAR,GAAsC,UAASV,EAAT,EAAaE,WAAb,EAA0B+B,eAA1B,EAA2C;EAC7E,IAAIL,CAAJ;EACA,IAAIM,CAAC,GAAGhC,WAAW,CAAC2B,MAApB;EAEA,IAAIM,UAAJ;;EAEA,KAAIP,CAAC,GAAG,CAAR,EAAWA,CAAC,GAAGM,CAAf,EAAkBN,CAAC,EAAnB,EAAuB;IACnB,IAAInB,OAAJ;IACA,IAAI2B,OAAO,GAAGlC,WAAW,CAAC0B,CAAD,CAAzB;IACA,IAAIS,MAAM,GAAGD,OAAO,CAACC,MAArB;IACA,IAAIC,IAAI,GAAGF,OAAO,CAACE,IAAnB;IAEA,IAAG,CAACC,KAAK,CAACC,OAAN,CAAcF,IAAd,CAAJ,EAAyBA,IAAI,GAAG,EAAP,CANN,CAQnB;;IACA,IAAG,CAACD,MAAJ,EAAY;MACR,OAAO,KAAP;IACH;;IACD,IAAII,QAAQ,GAAG3C,OAAO,CAAC4C,yBAAR,CAAkC1C,EAAlC,EAAsCqC,MAAtC,EAA8CC,IAA9C,CAAf,CAZmB,CAcnB;;IACA,IAAGG,QAAQ,CAACZ,MAAT,KAAoB,CAAvB,EAA0B;MACtB,OAAO,KAAP;IACH;;IAED,IAAG,CAACM,UAAJ,EAAgB;MACZA,UAAU,GAAGM,QAAQ,CAAC,CAAD,CAArB;;MACA,IAAGF,KAAK,CAACC,OAAN,CAAcL,UAAU,CAACZ,MAAzB,CAAH,EAAqC;QACjCY,UAAU,CAACZ,MAAX,CAAkBoB,IAAlB;MACH;IACJ,CALD,MAKO;MACHlC,OAAO,GAAGgC,QAAQ,CAAC,CAAD,CAAlB;;MACA,IAAGhC,OAAO,CAACY,IAAR,KAAiBc,UAAU,CAACd,IAA/B,EAAqC;QACjC,OAAO,KAAP;MACH;;MACD,IAAGZ,OAAO,CAACa,IAAR,KAAiBa,UAAU,CAACb,IAA/B,EAAqC;QACjC,OAAO,KAAP;MACH;;MACD,IAAGiB,KAAK,CAACC,OAAN,CAAcL,UAAU,CAACZ,MAAzB,CAAH,EAAqC;QACjC,IAAGgB,KAAK,CAACC,OAAN,CAAc/B,OAAO,CAACc,MAAtB,CAAH,EAAkC;UAC9Bd,OAAO,CAACc,MAAR,CAAeoB,IAAf;;UACA,KAAI,IAAIC,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAGT,UAAU,CAACZ,MAAX,CAAkBM,MAArC,EAA6Ce,CAAC,EAA9C,EAAkD;YAC9C,IAAGT,UAAU,CAACZ,MAAX,CAAkBqB,CAAlB,MAAyBnC,OAAO,CAACc,MAAR,CAAeqB,CAAf,CAA5B,EAA+C;cAC3C,OAAO,KAAP;YACH;UACJ;QACJ,CAPD,MAOO;UACH,OAAO,KAAP;QACH;MACJ,CAXD,MAWO;QACH,IAAGnC,OAAO,CAACa,IAAR,KAAiBa,UAAU,CAACb,IAA/B,EAAqC;UACjC,OAAO,KAAP;QACH;MACJ;IACJ;;IAEDb,OAAO,GAAGgC,QAAQ,CAAC,CAAD,CAAlB;IACA,IAAIzB,KAAK,GAAGP,OAAO,CAACO,KAApB;;IACA,IAAGuB,KAAK,CAACC,OAAN,CAAcxB,KAAd,CAAH,EAAyB;MACrB,IAAGA,KAAK,CAACa,MAAN,KAAiB,CAApB,EAAuB;QACnBb,KAAK,GAAGA,KAAK,CAAC,CAAD,CAAb;MACH,CAFD,MAEO;QACH,OAAO,KAAP;MACH;IACJ;;IACD,IAAGiB,eAAH,EAAoB;MAChBA,eAAe,CAACjB,KAAD,CAAf,GAAyBY,CAAzB;IACH;EACJ;;EAED,OAAOO,UAAP;AACH,CAvED;;AAyEA,SAASvB,sBAAT,CAAgCZ,EAAhC,EAAoCS,OAApC,EAA6CF,KAA7C,EAAoD;EAChD,IAAIN,SAAJ,EAAee,KAAf,EAAsB6B,GAAtB;EACA,IAAI9B,OAAO,GAAG,KAAd;;EAEA,IAAGN,OAAO,CAACY,IAAR,KAAiB,MAApB,EAA4B;IACxB;IACA;IACA;IACApB,SAAS,GAAGD,EAAE,CAAC8C,SAAH,CAAarC,OAAO,CAACc,MAAR,KAAmB,IAAnB,GAA0Bd,OAAO,CAACc,MAAR,CAAe,CAAf,CAA1B,GAA8C,CAA3D,CAAZ;EACH,CALD,MAKO,IAAGd,OAAO,CAACY,IAAR,KAAiB,QAApB,EAA8B;IACjCpB,SAAS,GAAGD,EAAE,CAAC+C,WAAf;EACH,CAFM,MAEA;IACH,OAAO,KAAP;EACH;;EAED/B,KAAK,GAAGnB,GAAG,CAACmD,cAAJ,CAAmB/C,SAAnB,EAA8BQ,OAAO,CAACa,IAAtC,EAA4C2B,GAA5C,EAAR;EAEAJ,GAAG,GAAGtC,KAAK,CAACE,OAAO,CAACY,IAAT,CAAL,GAAsBd,KAAK,CAACE,OAAO,CAACY,IAAT,CAAL,IAAuB,EAAnD;;EAEA,IAAGwB,GAAG,CAACK,cAAJ,CAAmBzC,OAAO,CAACa,IAA3B,CAAH,EAAqC;IACjC,IAAGuB,GAAG,CAACpC,OAAO,CAACa,IAAT,CAAH,KAAsBN,KAAzB,EAAgC;MAC5BD,OAAO,GAAG,IAAV;IACH;EACJ;;EAED8B,GAAG,CAACpC,OAAO,CAACa,IAAT,CAAH,GAAoBN,KAApB;EAEA,OAAO;IACHD,OAAO,EAAEA,OADN;IAEHC,KAAK,EAAEA;EAFJ,CAAP;AAIH;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAlB,OAAO,CAACqD,iBAAR,GAA4B,UAASnD,EAAT,EAAaqC,MAAb,EAAqBC,IAArB,EAA2B;EACnD,IAAGD,MAAM,KAAK,MAAd,EAAsB,OAAOlB,OAAO,CAACC,OAAR,EAAP;EAEtB,IAAIgC,OAAO,GAAGzD,QAAQ,CAAC0D,iBAAT,CAA2BhB,MAA3B,CAAd;EACA,IAAIiB,OAAO,GAAG,CAACtD,EAAD,CAAd;EACA,IAAG,CAACuC,KAAK,CAACC,OAAN,CAAcF,IAAd,CAAJ,EAAyBA,IAAI,GAAG,EAAP;;EAEzB,KAAI,IAAIV,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAGU,IAAI,CAACT,MAAxB,EAAgCD,CAAC,EAAjC,EAAqC;IACjC0B,OAAO,CAACC,IAAR,CAAajB,IAAI,CAACV,CAAD,CAAjB;EACH;;EAED,OAAOwB,OAAO,CAACI,KAAR,CAAc,IAAd,EAAoBF,OAApB,EAA6BG,KAA7B,CAAmC,UAASC,GAAT,EAAc;IACpD7D,GAAG,CAAC8D,IAAJ,CAAS,wBAAwBtB,MAAxB,GAAiC,YAA1C,EAAwDqB,GAAxD;IACA,OAAOvC,OAAO,CAACyC,MAAR,CAAeF,GAAf,CAAP;EACH,CAHM,CAAP;AAIH,CAfD;;AAiBA5D,OAAO,CAAC4C,yBAAR,GAAoC,UAAS1C,EAAT,EAAaqC,MAAb,EAAqBC,IAArB,EAA2B;EAC3D,IAAIG,QAAJ;EAEA,IAAG,CAACF,KAAK,CAACC,OAAN,CAAcF,IAAd,CAAJ,EAAyBA,IAAI,GAAG,EAAP;;EAEzB,QAAOD,MAAP;IACI,KAAK,SAAL;MACII,QAAQ,GAAGoB,mBAAmB,CAAC7D,EAAD,EAAKsC,IAAL,CAA9B;MACA;;IACJ,KAAK,UAAL;MACIG,QAAQ,GAAGqB,qBAAqB,CAAC9D,EAAD,EAAKsC,IAAL,CAAhC;MACA;;IACJ,KAAK,QAAL;MACIG,QAAQ,GAAGoB,mBAAmB,CAAC7D,EAAD,EAAK,CAACsC,IAAI,CAAC,CAAD,CAAL,EAAUA,IAAI,CAAC,CAAD,CAAd,CAAL,CAAnB,CACNyB,MADM,CACCD,qBAAqB,CAAC9D,EAAD,EAAK,CAACsC,IAAI,CAAC,CAAD,CAAL,CAAL,CADtB,CAAX;MAEA;;IACJ,KAAK,SAAL;MACIG,QAAQ,GAAGuB,sBAAsB,CAAChE,EAAD,EAAKsC,IAAL,CAAjC;MACA;;IACJ;MACI;MACA;MACA;MACAG,QAAQ,GAAG,EAAX;EAlBR;;EAoBA,OAAOA,QAAP;AACH,CA1BD;;AA4BA,SAASuB,sBAAT,CAAgChE,EAAhC,EAAoCsC,IAApC,EAA0C;EACtC;EACA;EACA,IAAGC,KAAK,CAACC,OAAN,CAAcF,IAAI,CAAC,CAAD,CAAlB,KAA0BA,IAAI,CAAC,CAAD,CAAJ,CAAQT,MAAR,KAAmB,CAA7C,IAAkD,CAAC,QAAD,EAAW,QAAX,EAAqBoC,OAArB,CAA6B,OAAO3B,IAAI,CAAC,CAAD,CAAJ,CAAQ,CAAR,CAApC,MAAoD,CAAC,CAA1G,EAA6G;IACzG,OAAO,CAAC;MAACjB,IAAI,EAAE,QAAP;MAAiBC,IAAI,EAAE,eAAvB;MAAwCN,KAAK,EAAEsB,IAAI,CAAC,CAAD,CAAJ,CAAQ,CAAR,EAAW4B,QAAX;IAA/C,CAAD,CAAP;EACH,CAFD,MAEO;IACH,OAAO,EAAP;EACH;AACJ;;AAED,SAASJ,qBAAT,CAA+B9D,EAA/B,EAAmCsC,IAAnC,EAAyC;EACrC,IAAIG,QAAQ,GAAG,EAAf;EAEA,IAAI0B,IAAI,GAAG7B,IAAI,CAAC,CAAD,CAAf;EACA,IAAI8B,IAAI,GAAG,EAAX;;EACA,IAAG,OAAOD,IAAP,KAAgB,QAAnB,EAA6B;IACzBC,IAAI,CAACD,IAAD,CAAJ,GAAa7B,IAAI,CAAC,CAAD,CAAjB;EACH,CAFD,MAEO,IAAGzC,GAAG,CAACwE,aAAJ,CAAkBF,IAAlB,CAAH,EAA4B;IAC/BC,IAAI,GAAGD,IAAP;EACH,CAFM,MAEA;IACH,OAAO1B,QAAP;EACH;;EAED6B,KAAK,CAACF,IAAD,EAAO,UAASG,IAAT,EAAeC,QAAf,EAAyBC,IAAzB,EAA+B;IACvChC,QAAQ,CAACc,IAAT,CAAc;MAAClC,IAAI,EAAE,QAAP;MAAiBC,IAAI,EAAEiD,IAAvB;MAA6BvD,KAAK,EAAEyD;IAApC,CAAd;EACH,CAFI,EAEF,EAFE,EAEE,CAFF,CAAL;EAIA,OAAOhC,QAAP;AACH;;AAED,SAASoB,mBAAT,CAA6B7D,EAA7B,EAAiCsC,IAAjC,EAAuC;EACnC,IAAIf,MAAJ,EAAY4C,IAAZ,EAAkBO,GAAlB,EAAuBN,IAAvB;EACA,IAAI3B,QAAQ,GAAG,EAAf,CAFmC,CAInC;;EACA0B,IAAI,GAAG7B,IAAI,CAAC,CAAD,CAAX;EACAoC,GAAG,GAAGpC,IAAI,CAAC,CAAD,CAAV;EACAf,MAAM,GAAGe,IAAI,CAAC,CAAD,CAAb;EACA8B,IAAI,GAAG,EAAP;;EACA,IAAG,OAAOD,IAAP,KAAgB,QAAnB,EAA6B;IACzBC,IAAI,CAACD,IAAD,CAAJ,GAAaO,GAAb;EACH,CAFD,MAEO,IAAG7E,GAAG,CAACwE,aAAJ,CAAkBF,IAAlB,CAAH,EAA4B;IAC/B;IACAC,IAAI,GAAGD,IAAP;;IAEA,IAAG5C,MAAM,KAAKN,SAAd,EAAyB;MACrBM,MAAM,GAAGmD,GAAT;IACH;EACJ,CAPM,MAOA;IACH,OAAOjC,QAAP;EACH;;EAED,IAAGlB,MAAM,KAAKN,SAAd,EAAyB;IACrB;IACAM,MAAM,GAAG,IAAT;EACH;;EAED+C,KAAK,CAACF,IAAD,EAAO,UAASG,IAAT,EAAeC,QAAf,EAAyBG,KAAzB,EAAgC;IACxC,IAAIC,UAAJ;IACA,IAAIH,IAAJ;;IAEA,IAAGlC,KAAK,CAACC,OAAN,CAAcmC,KAAd,CAAH,EAAyB;MACrBF,IAAI,GAAGE,KAAK,CAACE,KAAN,EAAP;MAEA,IAAIC,KAAK,GAAGC,IAAI,CAACC,GAAL,CAASP,IAAI,CAAC5C,MAAd,EAAsB7B,EAAE,CAACiF,IAAH,CAAQpD,MAA9B,CAAZ;;MACA,IAAGN,MAAH,EAAW;QACPuD,KAAK,GAAGC,IAAI,CAACC,GAAL,CAASF,KAAT,EAAgBvD,MAAM,CAACM,MAAvB,CAAR;MACH;;MACD+C,UAAU,GAAG,EAAb;;MACA,KAAI,IAAIhC,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAGkC,KAAnB,EAA0BlC,CAAC,EAA3B,EAA+B;QAC3BgC,UAAU,CAAChC,CAAD,CAAV,GAAgBrB,MAAM,GAAGA,MAAM,CAACqB,CAAD,CAAT,GAAeA,CAArC;MACH;IACJ,CAXD,MAWO;MACH6B,IAAI,GAAGE,KAAP;MACAC,UAAU,GAAGrD,MAAM,GAAGA,MAAM,CAACsD,KAAP,EAAH,GAAoB,IAAvC;IACH,CAlBuC,CAoBxC;;;IACA,IAAGD,UAAU,KAAK,IAAlB,EAAwB;MACpB,IAAGrC,KAAK,CAACC,OAAN,CAAciC,IAAd,CAAH,EAAwB;QACpBA,IAAI,GAAGA,IAAI,CAAC,CAAD,CAAX;MACH;IACJ,CAJD,MAIO,IAAGlC,KAAK,CAACC,OAAN,CAAcoC,UAAd,CAAH,EAA8B;MACjC,IAAG,CAACrC,KAAK,CAACC,OAAN,CAAciC,IAAd,CAAJ,EAAyB;QACrB,IAAIS,GAAG,GAAGT,IAAV;QACAA,IAAI,GAAG,EAAP;;QACA,KAAI,IAAI7C,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAGgD,UAAU,CAAC/C,MAA9B,EAAsCD,CAAC,EAAvC,EAA2C;UACvC6C,IAAI,CAAC7C,CAAD,CAAJ,GAAUsD,GAAV;QACH;MACJ;;MACDT,IAAI,CAAC5C,MAAL,GAAckD,IAAI,CAACC,GAAL,CAASJ,UAAU,CAAC/C,MAApB,EAA4B4C,IAAI,CAAC5C,MAAjC,CAAd;IACH;;IAEDY,QAAQ,CAACc,IAAT,CAAc;MACVlC,IAAI,EAAE,MADI;MAEVC,IAAI,EAAEiD,IAFI;MAGVhD,MAAM,EAAEqD,UAHE;MAIV5D,KAAK,EAAEyD;IAJG,CAAd;EAMH,CA1CI,EA0CF,EA1CE,EA0CE,CA1CF,CAAL;EA4CA,OAAOhC,QAAP;AACH;;AAED,SAAS6B,KAAT,CAAea,KAAf,EAAsBC,QAAtB,EAAgCb,IAAhC,EAAsCc,KAAtC,EAA6C;EACzCC,MAAM,CAACC,IAAP,CAAYJ,KAAZ,EAAmBK,OAAnB,CAA2B,UAAShB,QAAT,EAAmB;IAC1C,IAAIC,IAAI,GAAGU,KAAK,CAACX,QAAD,CAAhB;IAEA,IAAGA,QAAQ,CAAC,CAAD,CAAR,KAAgB,GAAnB,EAAwB;IAExB,IAAIiB,QAAQ,GAAGlB,IAAI,IAAIc,KAAK,GAAG,CAAR,GAAY,GAAZ,GAAkB,EAAtB,CAAJ,GAAgCb,QAA/C;;IAEA,IAAG3E,GAAG,CAACwE,aAAJ,CAAkBI,IAAlB,CAAH,EAA4B;MACxBH,KAAK,CAACG,IAAD,EAAOW,QAAP,EAAiBK,QAAjB,EAA2BJ,KAAK,GAAG,CAAnC,CAAL;IACH,CAFD,MAEO;MACH;MACAD,QAAQ,CAACK,QAAD,EAAWjB,QAAX,EAAqBC,IAArB,CAAR;IACH;EACJ,CAbD;AAcH"},"metadata":{},"sourceType":"script"}