{"ast":null,"code":"'use strict';\n\nvar Lib = require('../../lib');\n\nvar autorange = require('./autorange');\n\nvar id2name = require('./axis_ids').id2name;\n\nvar layoutAttributes = require('./layout_attributes');\n\nvar scaleZoom = require('./scale_zoom');\n\nvar setConvert = require('./set_convert');\n\nvar ALMOST_EQUAL = require('../../constants/numerical').ALMOST_EQUAL;\n\nvar FROM_BL = require('../../constants/alignment').FROM_BL;\n\nexports.handleDefaults = function (layoutIn, layoutOut, opts) {\n  var axIds = opts.axIds;\n  var axHasImage = opts.axHasImage; // sets of axes linked by `scaleanchor` OR `matches` along with the\n  // scaleratios compounded together, populated in handleConstraintDefaults\n\n  var constraintGroups = layoutOut._axisConstraintGroups = []; // similar to _axisConstraintGroups, but only matching axes\n\n  var matchGroups = layoutOut._axisMatchGroups = [];\n  var i, group, axId, axName, axIn, axOut, attr, val;\n\n  for (i = 0; i < axIds.length; i++) {\n    axName = id2name(axIds[i]);\n    axIn = layoutIn[axName];\n    axOut = layoutOut[axName];\n    handleOneAxDefaults(axIn, axOut, {\n      axIds: axIds,\n      layoutOut: layoutOut,\n      hasImage: axHasImage[axName]\n    });\n  } // save matchGroup on each matching axis\n\n\n  function stash(groups, stashAttr) {\n    for (i = 0; i < groups.length; i++) {\n      group = groups[i];\n\n      for (axId in group) {\n        layoutOut[id2name(axId)][stashAttr] = group;\n      }\n    }\n  }\n\n  stash(matchGroups, '_matchGroup'); // If any axis in a constraint group is fixedrange, they all get fixed\n  // This covers matches axes, as they're now in the constraintgroup too\n  // and have not yet been removed (if the group is *only* matching)\n\n  for (i = 0; i < constraintGroups.length; i++) {\n    group = constraintGroups[i];\n\n    for (axId in group) {\n      axOut = layoutOut[id2name(axId)];\n\n      if (axOut.fixedrange) {\n        for (var axId2 in group) {\n          var axName2 = id2name(axId2);\n\n          if ((layoutIn[axName2] || {}).fixedrange === false) {\n            Lib.warn('fixedrange was specified as false for axis ' + axName2 + ' but was overridden because another ' + 'axis in its constraint group has fixedrange true');\n          }\n\n          layoutOut[axName2].fixedrange = true;\n        }\n\n        break;\n      }\n    }\n  } // remove constraint groups that simply duplicate match groups\n\n\n  i = 0;\n\n  while (i < constraintGroups.length) {\n    group = constraintGroups[i];\n\n    for (axId in group) {\n      axOut = layoutOut[id2name(axId)];\n\n      if (axOut._matchGroup && Object.keys(axOut._matchGroup).length === Object.keys(group).length) {\n        constraintGroups.splice(i, 1);\n        i--;\n      }\n\n      break;\n    }\n\n    i++;\n  } // save constraintGroup on each constrained axis\n\n\n  stash(constraintGroups, '_constraintGroup'); // make sure `matching` axes share values of necessary attributes\n  // Precedence (base axis is the one that doesn't list a `matches`, ie others\n  // all point to it):\n  // (1) explicitly defined value in the base axis\n  // (2) explicitly defined in another axis (arbitrary order)\n  // (3) default in the base axis\n\n  var matchAttrs = ['constrain', 'range', 'autorange', 'rangemode', 'rangebreaks', 'categoryorder', 'categoryarray'];\n  var hasRange = false;\n  var hasDayOfWeekBreaks = false;\n\n  function setAttrVal() {\n    val = axOut[attr];\n\n    if (attr === 'rangebreaks') {\n      hasDayOfWeekBreaks = axOut._hasDayOfWeekBreaks;\n    }\n  }\n\n  for (i = 0; i < matchGroups.length; i++) {\n    group = matchGroups[i]; // find 'matching' range attrs\n\n    for (var j = 0; j < matchAttrs.length; j++) {\n      attr = matchAttrs[j];\n      val = null;\n      var baseAx;\n\n      for (axId in group) {\n        axName = id2name(axId);\n        axIn = layoutIn[axName];\n        axOut = layoutOut[axName];\n\n        if (!(attr in axOut)) {\n          continue;\n        }\n\n        if (!axOut.matches) {\n          baseAx = axOut; // top priority: explicit value in base axis\n\n          if (attr in axIn) {\n            setAttrVal();\n            break;\n          }\n        }\n\n        if (val === null && attr in axIn) {\n          // second priority: first explicit value in another axis\n          setAttrVal();\n        }\n      } // special logic for coupling of range and autorange\n      // if nobody explicitly specifies autorange, but someone does\n      // explicitly specify range, autorange must be disabled.\n\n\n      if (attr === 'range' && val) {\n        hasRange = true;\n      }\n\n      if (attr === 'autorange' && val === null && hasRange) {\n        val = false;\n      }\n\n      if (val === null && attr in baseAx) {\n        // fallback: default value in base axis\n        val = baseAx[attr];\n      } // but we still might not have a value, which is fine.\n\n\n      if (val !== null) {\n        for (axId in group) {\n          axOut = layoutOut[id2name(axId)];\n          axOut[attr] = attr === 'range' ? val.slice() : val;\n\n          if (attr === 'rangebreaks') {\n            axOut._hasDayOfWeekBreaks = hasDayOfWeekBreaks;\n            setConvert(axOut, layoutOut);\n          }\n        }\n      }\n    }\n  }\n};\n\nfunction handleOneAxDefaults(axIn, axOut, opts) {\n  var axIds = opts.axIds;\n  var layoutOut = opts.layoutOut;\n  var hasImage = opts.hasImage;\n  var constraintGroups = layoutOut._axisConstraintGroups;\n  var matchGroups = layoutOut._axisMatchGroups;\n  var axId = axOut._id;\n  var axLetter = axId.charAt(0);\n  var splomStash = ((layoutOut._splomAxes || {})[axLetter] || {})[axId] || {};\n  var thisID = axOut._id;\n  var isX = thisID.charAt(0) === 'x'; // Clear _matchGroup & _constraintGroup so relinkPrivateKeys doesn't keep\n  // an old one around. If this axis is in a group we'll set this again later\n\n  axOut._matchGroup = null;\n  axOut._constraintGroup = null;\n\n  function coerce(attr, dflt) {\n    return Lib.coerce(axIn, axOut, layoutAttributes, attr, dflt);\n  } // coerce the constraint mechanics even if this axis has no scaleanchor\n  // because it may be the anchor of another axis.\n\n\n  coerce('constrain', hasImage ? 'domain' : 'range');\n  Lib.coerce(axIn, axOut, {\n    constraintoward: {\n      valType: 'enumerated',\n      values: isX ? ['left', 'center', 'right'] : ['bottom', 'middle', 'top'],\n      dflt: isX ? 'center' : 'middle'\n    }\n  }, 'constraintoward'); // If this axis is already part of a constraint group, we can't\n  // scaleanchor any other axis in that group, or we'd make a loop.\n  // Filter axIds to enforce this, also matching axis types.\n\n  var thisType = axOut.type;\n  var i, idi;\n  var linkableAxes = [];\n\n  for (i = 0; i < axIds.length; i++) {\n    idi = axIds[i];\n    if (idi === thisID) continue;\n    var axi = layoutOut[id2name(idi)];\n\n    if (axi.type === thisType) {\n      linkableAxes.push(idi);\n    }\n  }\n\n  var thisGroup = getConstraintGroup(constraintGroups, thisID);\n\n  if (thisGroup) {\n    var linkableAxesNoLoops = [];\n\n    for (i = 0; i < linkableAxes.length; i++) {\n      idi = linkableAxes[i];\n      if (!thisGroup[idi]) linkableAxesNoLoops.push(idi);\n    }\n\n    linkableAxes = linkableAxesNoLoops;\n  }\n\n  var canLink = linkableAxes.length;\n  var matches, scaleanchor;\n\n  if (canLink && (axIn.matches || splomStash.matches)) {\n    matches = Lib.coerce(axIn, axOut, {\n      matches: {\n        valType: 'enumerated',\n        values: linkableAxes,\n        dflt: linkableAxes.indexOf(splomStash.matches) !== -1 ? splomStash.matches : undefined\n      }\n    }, 'matches');\n  } // 'matches' wins over 'scaleanchor' - each axis can only specify one\n  // constraint, but you can chain matches and scaleanchor constraints by\n  // specifying them in separate axes.\n\n\n  var scaleanchorDflt = hasImage && !isX ? axOut.anchor : undefined;\n\n  if (canLink && !matches && (axIn.scaleanchor || scaleanchorDflt)) {\n    scaleanchor = Lib.coerce(axIn, axOut, {\n      scaleanchor: {\n        valType: 'enumerated',\n        values: linkableAxes\n      }\n    }, 'scaleanchor', scaleanchorDflt);\n  }\n\n  if (matches) {\n    axOut._matchGroup = updateConstraintGroups(matchGroups, thisID, matches, 1); // Also include match constraints in the scale groups\n\n    var matchedAx = layoutOut[id2name(matches)];\n    var matchRatio = extent(layoutOut, axOut) / extent(layoutOut, matchedAx);\n\n    if (isX !== (matches.charAt(0) === 'x')) {\n      // We don't yet know the actual scale ratio of x/y matches constraints,\n      // due to possible automargins, so just leave a placeholder for this:\n      // 'x' means \"x size over y size\", 'y' means the inverse.\n      // in principle in the constraint group you could get multiple of these.\n      matchRatio = (isX ? 'x' : 'y') + matchRatio;\n    }\n\n    updateConstraintGroups(constraintGroups, thisID, matches, matchRatio);\n  } else if (axIn.matches && axIds.indexOf(axIn.matches) !== -1) {\n    Lib.warn('ignored ' + axOut._name + '.matches: \"' + axIn.matches + '\" to avoid an infinite loop');\n  }\n\n  if (scaleanchor) {\n    var scaleratio = coerce('scaleratio'); // TODO: I suppose I could do attribute.min: Number.MIN_VALUE to avoid zero,\n    // but that seems hacky. Better way to say \"must be a positive number\"?\n    // Of course if you use several super-tiny values you could eventually\n    // force a product of these to zero and all hell would break loose...\n    // Likewise with super-huge values.\n\n    if (!scaleratio) scaleratio = axOut.scaleratio = 1;\n    updateConstraintGroups(constraintGroups, thisID, scaleanchor, scaleratio);\n  } else if (axIn.scaleanchor && axIds.indexOf(axIn.scaleanchor) !== -1) {\n    Lib.warn('ignored ' + axOut._name + '.scaleanchor: \"' + axIn.scaleanchor + '\" to avoid either an infinite loop ' + 'and possibly inconsistent scaleratios, or because this axis ' + 'declares a *matches* constraint.');\n  }\n}\n\nfunction extent(layoutOut, ax) {\n  var domain = ax.domain;\n\n  if (!domain) {\n    // at this point overlaying axes haven't yet inherited their main domains\n    // TODO: constrain: domain with overlaying axes is likely a bug.\n    domain = layoutOut[id2name(ax.overlaying)].domain;\n  }\n\n  return domain[1] - domain[0];\n}\n\nfunction getConstraintGroup(groups, thisID) {\n  for (var i = 0; i < groups.length; i++) {\n    if (groups[i][thisID]) {\n      return groups[i];\n    }\n  }\n\n  return null;\n}\n/*\n * Add this axis to the axis constraint groups, which is the collection\n * of axes that are all constrained together on scale (or matching).\n *\n * constraintGroups: a list of objects. each object is\n * {axis_id: scale_within_group}, where scale_within_group is\n * only important relative to the rest of the group, and defines\n * the relative scales between all axes in the group\n *\n * thisGroup: the group the current axis is already in\n * thisID: the id if the current axis\n * thatID: the id of the axis to scale it with\n * scaleratio: the ratio of this axis to the thatID axis\n */\n\n\nfunction updateConstraintGroups(constraintGroups, thisID, thatID, scaleratio) {\n  var i, j, groupi, keyj, thisGroupIndex;\n  var thisGroup = getConstraintGroup(constraintGroups, thisID);\n\n  if (thisGroup === null) {\n    thisGroup = {};\n    thisGroup[thisID] = 1;\n    thisGroupIndex = constraintGroups.length;\n    constraintGroups.push(thisGroup);\n  } else {\n    thisGroupIndex = constraintGroups.indexOf(thisGroup);\n  }\n\n  var thisGroupKeys = Object.keys(thisGroup); // we know that this axis isn't in any other groups, but we don't know\n  // about the thatID axis. If it is, we need to merge the groups.\n\n  for (i = 0; i < constraintGroups.length; i++) {\n    groupi = constraintGroups[i];\n\n    if (i !== thisGroupIndex && groupi[thatID]) {\n      var baseScale = groupi[thatID];\n\n      for (j = 0; j < thisGroupKeys.length; j++) {\n        keyj = thisGroupKeys[j];\n        groupi[keyj] = multiplyScales(baseScale, multiplyScales(scaleratio, thisGroup[keyj]));\n      }\n\n      constraintGroups.splice(thisGroupIndex, 1);\n      return;\n    }\n  } // otherwise, we insert the new thatID axis as the base scale (1)\n  // in its group, and scale the rest of the group to it\n\n\n  if (scaleratio !== 1) {\n    for (j = 0; j < thisGroupKeys.length; j++) {\n      var key = thisGroupKeys[j];\n      thisGroup[key] = multiplyScales(scaleratio, thisGroup[key]);\n    }\n  }\n\n  thisGroup[thatID] = 1;\n} // scales may be numbers or 'x1.3', 'yy4.5' etc to multiply by as-yet-unknown\n// ratios between x and y plot sizes n times\n\n\nfunction multiplyScales(a, b) {\n  var aPrefix = '';\n  var bPrefix = '';\n  var aLen, bLen;\n\n  if (typeof a === 'string') {\n    aPrefix = a.match(/^[xy]*/)[0];\n    aLen = aPrefix.length;\n    a = +a.substr(aLen);\n  }\n\n  if (typeof b === 'string') {\n    bPrefix = b.match(/^[xy]*/)[0];\n    bLen = bPrefix.length;\n    b = +b.substr(bLen);\n  }\n\n  var c = a * b; // just two numbers\n\n  if (!aLen && !bLen) {\n    return c;\n  } // one or more prefixes of the same type\n\n\n  if (!aLen || !bLen || aPrefix.charAt(0) === bPrefix.charAt(0)) {\n    return aPrefix + bPrefix + a * b;\n  } // x and y cancel each other out exactly - back to a number\n\n\n  if (aLen === bLen) {\n    return c;\n  } // partial cancelation of prefixes\n\n\n  return (aLen > bLen ? aPrefix.substr(bLen) : bPrefix.substr(aLen)) + c;\n}\n\nfunction finalRatios(group, fullLayout) {\n  var size = fullLayout._size;\n  var yRatio = size.h / size.w;\n  var out = {};\n  var keys = Object.keys(group);\n\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    var val = group[key];\n\n    if (typeof val === 'string') {\n      var prefix = val.match(/^[xy]*/)[0];\n      var pLen = prefix.length;\n      val = +val.substr(pLen);\n      var mult = prefix.charAt(0) === 'y' ? yRatio : 1 / yRatio;\n\n      for (var j = 0; j < pLen; j++) {\n        val *= mult;\n      }\n    }\n\n    out[key] = val;\n  }\n\n  return out;\n}\n\nexports.enforce = function enforce(gd) {\n  var fullLayout = gd._fullLayout;\n  var constraintGroups = fullLayout._axisConstraintGroups || [];\n  var i, j, group, axisID, ax, normScale, mode, factor; // matching constraints are handled in the autorange code when autoranged,\n  // or in the supplyDefaults code when explicitly ranged.\n  // now we just need to handle scaleanchor constraints\n  // matches constraints that chain with scaleanchor constraints are included\n  // here too, but because matches has already been satisfied,\n  // any changes here should preserve that.\n\n  for (i = 0; i < constraintGroups.length; i++) {\n    group = finalRatios(constraintGroups[i], fullLayout);\n    var axisIDs = Object.keys(group);\n    var minScale = Infinity;\n    var maxScale = 0; // mostly matchScale will be the same as minScale\n    // ie we expand axis ranges to encompass *everything*\n    // that's currently in any of their ranges, but during\n    // autorange of a subset of axes we will ignore other\n    // axes for this purpose.\n\n    var matchScale = Infinity;\n    var normScales = {};\n    var axes = {};\n    var hasAnyDomainConstraint = false; // find the (normalized) scale of each axis in the group\n\n    for (j = 0; j < axisIDs.length; j++) {\n      axisID = axisIDs[j];\n      axes[axisID] = ax = fullLayout[id2name(axisID)];\n      if (ax._inputDomain) ax.domain = ax._inputDomain.slice();else ax._inputDomain = ax.domain.slice();\n      if (!ax._inputRange) ax._inputRange = ax.range.slice(); // set axis scale here so we can use _m rather than\n      // having to calculate it from length and range\n\n      ax.setScale(); // abs: inverted scales still satisfy the constraint\n\n      normScales[axisID] = normScale = Math.abs(ax._m) / group[axisID];\n      minScale = Math.min(minScale, normScale);\n\n      if (ax.constrain === 'domain' || !ax._constraintShrinkable) {\n        matchScale = Math.min(matchScale, normScale);\n      } // this has served its purpose, so remove it\n\n\n      delete ax._constraintShrinkable;\n      maxScale = Math.max(maxScale, normScale);\n      if (ax.constrain === 'domain') hasAnyDomainConstraint = true;\n    } // Do we have a constraint mismatch? Give a small buffer for rounding errors\n\n\n    if (minScale > ALMOST_EQUAL * maxScale && !hasAnyDomainConstraint) continue; // now increase any ranges we need to until all normalized scales are equal\n\n    for (j = 0; j < axisIDs.length; j++) {\n      axisID = axisIDs[j];\n      normScale = normScales[axisID];\n      ax = axes[axisID];\n      mode = ax.constrain; // even if the scale didn't change, if we're shrinking domain\n      // we need to recalculate in case `constraintoward` changed\n\n      if (normScale !== matchScale || mode === 'domain') {\n        factor = normScale / matchScale;\n\n        if (mode === 'range') {\n          scaleZoom(ax, factor);\n        } else {\n          // mode === 'domain'\n          var inputDomain = ax._inputDomain;\n          var domainShrunk = (ax.domain[1] - ax.domain[0]) / (inputDomain[1] - inputDomain[0]);\n          var rangeShrunk = (ax.r2l(ax.range[1]) - ax.r2l(ax.range[0])) / (ax.r2l(ax._inputRange[1]) - ax.r2l(ax._inputRange[0]));\n          factor /= domainShrunk;\n\n          if (factor * rangeShrunk < 1) {\n            // we've asked to magnify the axis more than we can just by\n            // enlarging the domain - so we need to constrict range\n            ax.domain = ax._input.domain = inputDomain.slice();\n            scaleZoom(ax, factor);\n            continue;\n          }\n\n          if (rangeShrunk < 1) {\n            // the range has previously been constricted by ^^, but we've\n            // switched to the domain-constricted regime, so reset range\n            ax.range = ax._input.range = ax._inputRange.slice();\n            factor *= rangeShrunk;\n          }\n\n          if (ax.autorange) {\n            /*\n             * range & factor may need to change because range was\n             * calculated for the larger scaling, so some pixel\n             * paddings may get cut off when we reduce the domain.\n             *\n             * This is easier than the regular autorange calculation\n             * because we already know the scaling `m`, but we still\n             * need to cut out impossible constraints (like\n             * annotations with super-long arrows). That's what\n             * outerMin/Max are for - if the expansion was going to\n             * go beyond the original domain, it must be impossible\n             */\n            var rl0 = ax.r2l(ax.range[0]);\n            var rl1 = ax.r2l(ax.range[1]);\n            var rangeCenter = (rl0 + rl1) / 2;\n            var rangeMin = rangeCenter;\n            var rangeMax = rangeCenter;\n            var halfRange = Math.abs(rl1 - rangeCenter); // extra tiny bit for rounding errors, in case we actually\n            // *are* expanding to the full domain\n\n            var outerMin = rangeCenter - halfRange * factor * 1.0001;\n            var outerMax = rangeCenter + halfRange * factor * 1.0001;\n            var getPadMin = autorange.makePadFn(fullLayout, ax, 0);\n            var getPadMax = autorange.makePadFn(fullLayout, ax, 1);\n            updateDomain(ax, factor);\n            var m = Math.abs(ax._m);\n            var extremes = autorange.concatExtremes(gd, ax);\n            var minArray = extremes.min;\n            var maxArray = extremes.max;\n            var newVal;\n            var k;\n\n            for (k = 0; k < minArray.length; k++) {\n              newVal = minArray[k].val - getPadMin(minArray[k]) / m;\n\n              if (newVal > outerMin && newVal < rangeMin) {\n                rangeMin = newVal;\n              }\n            }\n\n            for (k = 0; k < maxArray.length; k++) {\n              newVal = maxArray[k].val + getPadMax(maxArray[k]) / m;\n\n              if (newVal < outerMax && newVal > rangeMax) {\n                rangeMax = newVal;\n              }\n            }\n\n            var domainExpand = (rangeMax - rangeMin) / (2 * halfRange);\n            factor /= domainExpand;\n            rangeMin = ax.l2r(rangeMin);\n            rangeMax = ax.l2r(rangeMax);\n            ax.range = ax._input.range = rl0 < rl1 ? [rangeMin, rangeMax] : [rangeMax, rangeMin];\n          }\n\n          updateDomain(ax, factor);\n        }\n      }\n    }\n  }\n};\n\nexports.getAxisGroup = function getAxisGroup(fullLayout, axId) {\n  var matchGroups = fullLayout._axisMatchGroups;\n\n  for (var i = 0; i < matchGroups.length; i++) {\n    var group = matchGroups[i];\n    if (group[axId]) return 'g' + i;\n  }\n\n  return axId;\n}; // For use before autoranging, check if this axis was previously constrained\n// by domain but no longer is\n\n\nexports.clean = function clean(gd, ax) {\n  if (ax._inputDomain) {\n    var isConstrained = false;\n    var axId = ax._id;\n    var constraintGroups = gd._fullLayout._axisConstraintGroups;\n\n    for (var j = 0; j < constraintGroups.length; j++) {\n      if (constraintGroups[j][axId]) {\n        isConstrained = true;\n        break;\n      }\n    }\n\n    if (!isConstrained || ax.constrain !== 'domain') {\n      ax._input.domain = ax.domain = ax._inputDomain;\n      delete ax._inputDomain;\n    }\n  }\n};\n\nfunction updateDomain(ax, factor) {\n  var inputDomain = ax._inputDomain;\n  var centerFraction = FROM_BL[ax.constraintoward];\n  var center = inputDomain[0] + (inputDomain[1] - inputDomain[0]) * centerFraction;\n  ax.domain = ax._input.domain = [center + (inputDomain[0] - center) / factor, center + (inputDomain[1] - center) / factor];\n  ax.setScale();\n}","map":{"version":3,"names":["Lib","require","autorange","id2name","layoutAttributes","scaleZoom","setConvert","ALMOST_EQUAL","FROM_BL","exports","handleDefaults","layoutIn","layoutOut","opts","axIds","axHasImage","constraintGroups","_axisConstraintGroups","matchGroups","_axisMatchGroups","i","group","axId","axName","axIn","axOut","attr","val","length","handleOneAxDefaults","hasImage","stash","groups","stashAttr","fixedrange","axId2","axName2","warn","_matchGroup","Object","keys","splice","matchAttrs","hasRange","hasDayOfWeekBreaks","setAttrVal","_hasDayOfWeekBreaks","j","baseAx","matches","slice","_id","axLetter","charAt","splomStash","_splomAxes","thisID","isX","_constraintGroup","coerce","dflt","constraintoward","valType","values","thisType","type","idi","linkableAxes","axi","push","thisGroup","getConstraintGroup","linkableAxesNoLoops","canLink","scaleanchor","indexOf","undefined","scaleanchorDflt","anchor","updateConstraintGroups","matchedAx","matchRatio","extent","_name","scaleratio","ax","domain","overlaying","thatID","groupi","keyj","thisGroupIndex","thisGroupKeys","baseScale","multiplyScales","key","a","b","aPrefix","bPrefix","aLen","bLen","match","substr","c","finalRatios","fullLayout","size","_size","yRatio","h","w","out","prefix","pLen","mult","enforce","gd","_fullLayout","axisID","normScale","mode","factor","axisIDs","minScale","Infinity","maxScale","matchScale","normScales","axes","hasAnyDomainConstraint","_inputDomain","_inputRange","range","setScale","Math","abs","_m","min","constrain","_constraintShrinkable","max","inputDomain","domainShrunk","rangeShrunk","r2l","_input","rl0","rl1","rangeCenter","rangeMin","rangeMax","halfRange","outerMin","outerMax","getPadMin","makePadFn","getPadMax","updateDomain","m","extremes","concatExtremes","minArray","maxArray","newVal","k","domainExpand","l2r","getAxisGroup","clean","isConstrained","centerFraction","center"],"sources":["D:/Rohit/Git projects/Manthan/node_modules/plotly.js/src/plots/cartesian/constraints.js"],"sourcesContent":["'use strict';\n\nvar Lib = require('../../lib');\n\nvar autorange = require('./autorange');\nvar id2name = require('./axis_ids').id2name;\nvar layoutAttributes = require('./layout_attributes');\nvar scaleZoom = require('./scale_zoom');\nvar setConvert = require('./set_convert');\n\nvar ALMOST_EQUAL = require('../../constants/numerical').ALMOST_EQUAL;\nvar FROM_BL = require('../../constants/alignment').FROM_BL;\n\nexports.handleDefaults = function(layoutIn, layoutOut, opts) {\n    var axIds = opts.axIds;\n    var axHasImage = opts.axHasImage;\n\n    // sets of axes linked by `scaleanchor` OR `matches` along with the\n    // scaleratios compounded together, populated in handleConstraintDefaults\n    var constraintGroups = layoutOut._axisConstraintGroups = [];\n    // similar to _axisConstraintGroups, but only matching axes\n    var matchGroups = layoutOut._axisMatchGroups = [];\n\n    var i, group, axId, axName, axIn, axOut, attr, val;\n\n    for(i = 0; i < axIds.length; i++) {\n        axName = id2name(axIds[i]);\n        axIn = layoutIn[axName];\n        axOut = layoutOut[axName];\n\n        handleOneAxDefaults(axIn, axOut, {\n            axIds: axIds,\n            layoutOut: layoutOut,\n            hasImage: axHasImage[axName]\n        });\n    }\n\n    // save matchGroup on each matching axis\n    function stash(groups, stashAttr) {\n        for(i = 0; i < groups.length; i++) {\n            group = groups[i];\n            for(axId in group) {\n                layoutOut[id2name(axId)][stashAttr] = group;\n            }\n        }\n    }\n    stash(matchGroups, '_matchGroup');\n\n    // If any axis in a constraint group is fixedrange, they all get fixed\n    // This covers matches axes, as they're now in the constraintgroup too\n    // and have not yet been removed (if the group is *only* matching)\n    for(i = 0; i < constraintGroups.length; i++) {\n        group = constraintGroups[i];\n        for(axId in group) {\n            axOut = layoutOut[id2name(axId)];\n            if(axOut.fixedrange) {\n                for(var axId2 in group) {\n                    var axName2 = id2name(axId2);\n                    if((layoutIn[axName2] || {}).fixedrange === false) {\n                        Lib.warn(\n                            'fixedrange was specified as false for axis ' +\n                            axName2 + ' but was overridden because another ' +\n                            'axis in its constraint group has fixedrange true'\n                        );\n                    }\n                    layoutOut[axName2].fixedrange = true;\n                }\n                break;\n            }\n        }\n    }\n\n    // remove constraint groups that simply duplicate match groups\n    i = 0;\n    while(i < constraintGroups.length) {\n        group = constraintGroups[i];\n        for(axId in group) {\n            axOut = layoutOut[id2name(axId)];\n            if(axOut._matchGroup && Object.keys(axOut._matchGroup).length === Object.keys(group).length) {\n                constraintGroups.splice(i, 1);\n                i--;\n            }\n            break;\n        }\n        i++;\n    }\n\n    // save constraintGroup on each constrained axis\n    stash(constraintGroups, '_constraintGroup');\n\n    // make sure `matching` axes share values of necessary attributes\n    // Precedence (base axis is the one that doesn't list a `matches`, ie others\n    // all point to it):\n    // (1) explicitly defined value in the base axis\n    // (2) explicitly defined in another axis (arbitrary order)\n    // (3) default in the base axis\n    var matchAttrs = [\n        'constrain',\n        'range',\n        'autorange',\n        'rangemode',\n        'rangebreaks',\n        'categoryorder',\n        'categoryarray'\n    ];\n    var hasRange = false;\n    var hasDayOfWeekBreaks = false;\n\n    function setAttrVal() {\n        val = axOut[attr];\n        if(attr === 'rangebreaks') {\n            hasDayOfWeekBreaks = axOut._hasDayOfWeekBreaks;\n        }\n    }\n\n    for(i = 0; i < matchGroups.length; i++) {\n        group = matchGroups[i];\n\n        // find 'matching' range attrs\n        for(var j = 0; j < matchAttrs.length; j++) {\n            attr = matchAttrs[j];\n            val = null;\n            var baseAx;\n            for(axId in group) {\n                axName = id2name(axId);\n                axIn = layoutIn[axName];\n                axOut = layoutOut[axName];\n                if(!(attr in axOut)) {\n                    continue;\n                }\n                if(!axOut.matches) {\n                    baseAx = axOut;\n                    // top priority: explicit value in base axis\n                    if(attr in axIn) {\n                        setAttrVal();\n                        break;\n                    }\n                }\n                if(val === null && attr in axIn) {\n                    // second priority: first explicit value in another axis\n                    setAttrVal();\n                }\n            }\n\n            // special logic for coupling of range and autorange\n            // if nobody explicitly specifies autorange, but someone does\n            // explicitly specify range, autorange must be disabled.\n            if(attr === 'range' && val) {\n                hasRange = true;\n            }\n            if(attr === 'autorange' && val === null && hasRange) {\n                val = false;\n            }\n\n            if(val === null && attr in baseAx) {\n                // fallback: default value in base axis\n                val = baseAx[attr];\n            }\n            // but we still might not have a value, which is fine.\n            if(val !== null) {\n                for(axId in group) {\n                    axOut = layoutOut[id2name(axId)];\n                    axOut[attr] = attr === 'range' ? val.slice() : val;\n\n                    if(attr === 'rangebreaks') {\n                        axOut._hasDayOfWeekBreaks = hasDayOfWeekBreaks;\n                        setConvert(axOut, layoutOut);\n                    }\n                }\n            }\n        }\n    }\n};\n\nfunction handleOneAxDefaults(axIn, axOut, opts) {\n    var axIds = opts.axIds;\n    var layoutOut = opts.layoutOut;\n    var hasImage = opts.hasImage;\n    var constraintGroups = layoutOut._axisConstraintGroups;\n    var matchGroups = layoutOut._axisMatchGroups;\n    var axId = axOut._id;\n    var axLetter = axId.charAt(0);\n    var splomStash = ((layoutOut._splomAxes || {})[axLetter] || {})[axId] || {};\n    var thisID = axOut._id;\n    var isX = thisID.charAt(0) === 'x';\n\n    // Clear _matchGroup & _constraintGroup so relinkPrivateKeys doesn't keep\n    // an old one around. If this axis is in a group we'll set this again later\n    axOut._matchGroup = null;\n    axOut._constraintGroup = null;\n\n    function coerce(attr, dflt) {\n        return Lib.coerce(axIn, axOut, layoutAttributes, attr, dflt);\n    }\n\n    // coerce the constraint mechanics even if this axis has no scaleanchor\n    // because it may be the anchor of another axis.\n    coerce('constrain', hasImage ? 'domain' : 'range');\n    Lib.coerce(axIn, axOut, {\n        constraintoward: {\n            valType: 'enumerated',\n            values: isX ? ['left', 'center', 'right'] : ['bottom', 'middle', 'top'],\n            dflt: isX ? 'center' : 'middle'\n        }\n    }, 'constraintoward');\n\n    // If this axis is already part of a constraint group, we can't\n    // scaleanchor any other axis in that group, or we'd make a loop.\n    // Filter axIds to enforce this, also matching axis types.\n    var thisType = axOut.type;\n    var i, idi;\n\n    var linkableAxes = [];\n    for(i = 0; i < axIds.length; i++) {\n        idi = axIds[i];\n        if(idi === thisID) continue;\n\n        var axi = layoutOut[id2name(idi)];\n        if(axi.type === thisType) {\n            linkableAxes.push(idi);\n        }\n    }\n\n    var thisGroup = getConstraintGroup(constraintGroups, thisID);\n    if(thisGroup) {\n        var linkableAxesNoLoops = [];\n        for(i = 0; i < linkableAxes.length; i++) {\n            idi = linkableAxes[i];\n            if(!thisGroup[idi]) linkableAxesNoLoops.push(idi);\n        }\n        linkableAxes = linkableAxesNoLoops;\n    }\n\n    var canLink = linkableAxes.length;\n\n    var matches, scaleanchor;\n\n    if(canLink && (axIn.matches || splomStash.matches)) {\n        matches = Lib.coerce(axIn, axOut, {\n            matches: {\n                valType: 'enumerated',\n                values: linkableAxes,\n                dflt: linkableAxes.indexOf(splomStash.matches) !== -1 ? splomStash.matches : undefined\n            }\n        }, 'matches');\n    }\n\n    // 'matches' wins over 'scaleanchor' - each axis can only specify one\n    // constraint, but you can chain matches and scaleanchor constraints by\n    // specifying them in separate axes.\n    var scaleanchorDflt = hasImage && !isX ? axOut.anchor : undefined;\n    if(canLink && !matches && (axIn.scaleanchor || scaleanchorDflt)) {\n        scaleanchor = Lib.coerce(axIn, axOut, {\n            scaleanchor: {\n                valType: 'enumerated',\n                values: linkableAxes\n            }\n        }, 'scaleanchor', scaleanchorDflt);\n    }\n\n    if(matches) {\n        axOut._matchGroup = updateConstraintGroups(matchGroups, thisID, matches, 1);\n\n        // Also include match constraints in the scale groups\n        var matchedAx = layoutOut[id2name(matches)];\n        var matchRatio = extent(layoutOut, axOut) / extent(layoutOut, matchedAx);\n        if(isX !== (matches.charAt(0) === 'x')) {\n            // We don't yet know the actual scale ratio of x/y matches constraints,\n            // due to possible automargins, so just leave a placeholder for this:\n            // 'x' means \"x size over y size\", 'y' means the inverse.\n            // in principle in the constraint group you could get multiple of these.\n            matchRatio = (isX ? 'x' : 'y') + matchRatio;\n        }\n        updateConstraintGroups(constraintGroups, thisID, matches, matchRatio);\n    } else if(axIn.matches && axIds.indexOf(axIn.matches) !== -1) {\n        Lib.warn('ignored ' + axOut._name + '.matches: \"' +\n            axIn.matches + '\" to avoid an infinite loop');\n    }\n\n    if(scaleanchor) {\n        var scaleratio = coerce('scaleratio');\n\n        // TODO: I suppose I could do attribute.min: Number.MIN_VALUE to avoid zero,\n        // but that seems hacky. Better way to say \"must be a positive number\"?\n        // Of course if you use several super-tiny values you could eventually\n        // force a product of these to zero and all hell would break loose...\n        // Likewise with super-huge values.\n        if(!scaleratio) scaleratio = axOut.scaleratio = 1;\n\n        updateConstraintGroups(constraintGroups, thisID, scaleanchor, scaleratio);\n    } else if(axIn.scaleanchor && axIds.indexOf(axIn.scaleanchor) !== -1) {\n        Lib.warn('ignored ' + axOut._name + '.scaleanchor: \"' +\n            axIn.scaleanchor + '\" to avoid either an infinite loop ' +\n            'and possibly inconsistent scaleratios, or because this axis ' +\n            'declares a *matches* constraint.');\n    }\n}\n\nfunction extent(layoutOut, ax) {\n    var domain = ax.domain;\n    if(!domain) {\n        // at this point overlaying axes haven't yet inherited their main domains\n        // TODO: constrain: domain with overlaying axes is likely a bug.\n        domain = layoutOut[id2name(ax.overlaying)].domain;\n    }\n    return domain[1] - domain[0];\n}\n\nfunction getConstraintGroup(groups, thisID) {\n    for(var i = 0; i < groups.length; i++) {\n        if(groups[i][thisID]) {\n            return groups[i];\n        }\n    }\n    return null;\n}\n\n/*\n * Add this axis to the axis constraint groups, which is the collection\n * of axes that are all constrained together on scale (or matching).\n *\n * constraintGroups: a list of objects. each object is\n * {axis_id: scale_within_group}, where scale_within_group is\n * only important relative to the rest of the group, and defines\n * the relative scales between all axes in the group\n *\n * thisGroup: the group the current axis is already in\n * thisID: the id if the current axis\n * thatID: the id of the axis to scale it with\n * scaleratio: the ratio of this axis to the thatID axis\n */\nfunction updateConstraintGroups(constraintGroups, thisID, thatID, scaleratio) {\n    var i, j, groupi, keyj, thisGroupIndex;\n\n    var thisGroup = getConstraintGroup(constraintGroups, thisID);\n\n    if(thisGroup === null) {\n        thisGroup = {};\n        thisGroup[thisID] = 1;\n        thisGroupIndex = constraintGroups.length;\n        constraintGroups.push(thisGroup);\n    } else {\n        thisGroupIndex = constraintGroups.indexOf(thisGroup);\n    }\n\n    var thisGroupKeys = Object.keys(thisGroup);\n\n    // we know that this axis isn't in any other groups, but we don't know\n    // about the thatID axis. If it is, we need to merge the groups.\n    for(i = 0; i < constraintGroups.length; i++) {\n        groupi = constraintGroups[i];\n        if(i !== thisGroupIndex && groupi[thatID]) {\n            var baseScale = groupi[thatID];\n            for(j = 0; j < thisGroupKeys.length; j++) {\n                keyj = thisGroupKeys[j];\n                groupi[keyj] = multiplyScales(baseScale, multiplyScales(scaleratio, thisGroup[keyj]));\n            }\n            constraintGroups.splice(thisGroupIndex, 1);\n            return;\n        }\n    }\n\n    // otherwise, we insert the new thatID axis as the base scale (1)\n    // in its group, and scale the rest of the group to it\n    if(scaleratio !== 1) {\n        for(j = 0; j < thisGroupKeys.length; j++) {\n            var key = thisGroupKeys[j];\n            thisGroup[key] = multiplyScales(scaleratio, thisGroup[key]);\n        }\n    }\n    thisGroup[thatID] = 1;\n}\n\n// scales may be numbers or 'x1.3', 'yy4.5' etc to multiply by as-yet-unknown\n// ratios between x and y plot sizes n times\nfunction multiplyScales(a, b) {\n    var aPrefix = '';\n    var bPrefix = '';\n    var aLen, bLen;\n\n    if(typeof a === 'string') {\n        aPrefix = a.match(/^[xy]*/)[0];\n        aLen = aPrefix.length;\n        a = +a.substr(aLen);\n    }\n\n    if(typeof b === 'string') {\n        bPrefix = b.match(/^[xy]*/)[0];\n        bLen = bPrefix.length;\n        b = +b.substr(bLen);\n    }\n\n    var c = a * b;\n\n    // just two numbers\n    if(!aLen && !bLen) {\n        return c;\n    }\n\n    // one or more prefixes of the same type\n    if(!aLen || !bLen || aPrefix.charAt(0) === bPrefix.charAt(0)) {\n        return aPrefix + bPrefix + (a * b);\n    }\n\n    // x and y cancel each other out exactly - back to a number\n    if(aLen === bLen) {\n        return c;\n    }\n\n    // partial cancelation of prefixes\n    return (aLen > bLen ? aPrefix.substr(bLen) : bPrefix.substr(aLen)) + c;\n}\n\nfunction finalRatios(group, fullLayout) {\n    var size = fullLayout._size;\n    var yRatio = size.h / size.w;\n    var out = {};\n    var keys = Object.keys(group);\n    for(var i = 0; i < keys.length; i++) {\n        var key = keys[i];\n        var val = group[key];\n\n        if(typeof val === 'string') {\n            var prefix = val.match(/^[xy]*/)[0];\n            var pLen = prefix.length;\n            val = +val.substr(pLen);\n            var mult = prefix.charAt(0) === 'y' ? yRatio : (1 / yRatio);\n            for(var j = 0; j < pLen; j++) {\n                val *= mult;\n            }\n        }\n\n        out[key] = val;\n    }\n    return out;\n}\n\nexports.enforce = function enforce(gd) {\n    var fullLayout = gd._fullLayout;\n    var constraintGroups = fullLayout._axisConstraintGroups || [];\n\n    var i, j, group, axisID, ax, normScale, mode, factor;\n\n    // matching constraints are handled in the autorange code when autoranged,\n    // or in the supplyDefaults code when explicitly ranged.\n    // now we just need to handle scaleanchor constraints\n    // matches constraints that chain with scaleanchor constraints are included\n    // here too, but because matches has already been satisfied,\n    // any changes here should preserve that.\n    for(i = 0; i < constraintGroups.length; i++) {\n        group = finalRatios(constraintGroups[i], fullLayout);\n        var axisIDs = Object.keys(group);\n\n        var minScale = Infinity;\n        var maxScale = 0;\n        // mostly matchScale will be the same as minScale\n        // ie we expand axis ranges to encompass *everything*\n        // that's currently in any of their ranges, but during\n        // autorange of a subset of axes we will ignore other\n        // axes for this purpose.\n        var matchScale = Infinity;\n        var normScales = {};\n        var axes = {};\n        var hasAnyDomainConstraint = false;\n\n        // find the (normalized) scale of each axis in the group\n        for(j = 0; j < axisIDs.length; j++) {\n            axisID = axisIDs[j];\n            axes[axisID] = ax = fullLayout[id2name(axisID)];\n\n            if(ax._inputDomain) ax.domain = ax._inputDomain.slice();\n            else ax._inputDomain = ax.domain.slice();\n\n            if(!ax._inputRange) ax._inputRange = ax.range.slice();\n\n            // set axis scale here so we can use _m rather than\n            // having to calculate it from length and range\n            ax.setScale();\n\n            // abs: inverted scales still satisfy the constraint\n            normScales[axisID] = normScale = Math.abs(ax._m) / group[axisID];\n            minScale = Math.min(minScale, normScale);\n            if(ax.constrain === 'domain' || !ax._constraintShrinkable) {\n                matchScale = Math.min(matchScale, normScale);\n            }\n\n            // this has served its purpose, so remove it\n            delete ax._constraintShrinkable;\n            maxScale = Math.max(maxScale, normScale);\n\n            if(ax.constrain === 'domain') hasAnyDomainConstraint = true;\n        }\n\n        // Do we have a constraint mismatch? Give a small buffer for rounding errors\n        if(minScale > ALMOST_EQUAL * maxScale && !hasAnyDomainConstraint) continue;\n\n        // now increase any ranges we need to until all normalized scales are equal\n        for(j = 0; j < axisIDs.length; j++) {\n            axisID = axisIDs[j];\n            normScale = normScales[axisID];\n            ax = axes[axisID];\n            mode = ax.constrain;\n\n            // even if the scale didn't change, if we're shrinking domain\n            // we need to recalculate in case `constraintoward` changed\n            if(normScale !== matchScale || mode === 'domain') {\n                factor = normScale / matchScale;\n\n                if(mode === 'range') {\n                    scaleZoom(ax, factor);\n                } else {\n                    // mode === 'domain'\n\n                    var inputDomain = ax._inputDomain;\n                    var domainShrunk = (ax.domain[1] - ax.domain[0]) /\n                        (inputDomain[1] - inputDomain[0]);\n                    var rangeShrunk = (ax.r2l(ax.range[1]) - ax.r2l(ax.range[0])) /\n                        (ax.r2l(ax._inputRange[1]) - ax.r2l(ax._inputRange[0]));\n\n                    factor /= domainShrunk;\n\n                    if(factor * rangeShrunk < 1) {\n                        // we've asked to magnify the axis more than we can just by\n                        // enlarging the domain - so we need to constrict range\n                        ax.domain = ax._input.domain = inputDomain.slice();\n                        scaleZoom(ax, factor);\n                        continue;\n                    }\n\n                    if(rangeShrunk < 1) {\n                        // the range has previously been constricted by ^^, but we've\n                        // switched to the domain-constricted regime, so reset range\n                        ax.range = ax._input.range = ax._inputRange.slice();\n                        factor *= rangeShrunk;\n                    }\n\n                    if(ax.autorange) {\n                        /*\n                         * range & factor may need to change because range was\n                         * calculated for the larger scaling, so some pixel\n                         * paddings may get cut off when we reduce the domain.\n                         *\n                         * This is easier than the regular autorange calculation\n                         * because we already know the scaling `m`, but we still\n                         * need to cut out impossible constraints (like\n                         * annotations with super-long arrows). That's what\n                         * outerMin/Max are for - if the expansion was going to\n                         * go beyond the original domain, it must be impossible\n                         */\n                        var rl0 = ax.r2l(ax.range[0]);\n                        var rl1 = ax.r2l(ax.range[1]);\n                        var rangeCenter = (rl0 + rl1) / 2;\n                        var rangeMin = rangeCenter;\n                        var rangeMax = rangeCenter;\n                        var halfRange = Math.abs(rl1 - rangeCenter);\n                        // extra tiny bit for rounding errors, in case we actually\n                        // *are* expanding to the full domain\n                        var outerMin = rangeCenter - halfRange * factor * 1.0001;\n                        var outerMax = rangeCenter + halfRange * factor * 1.0001;\n                        var getPadMin = autorange.makePadFn(fullLayout, ax, 0);\n                        var getPadMax = autorange.makePadFn(fullLayout, ax, 1);\n\n                        updateDomain(ax, factor);\n                        var m = Math.abs(ax._m);\n                        var extremes = autorange.concatExtremes(gd, ax);\n                        var minArray = extremes.min;\n                        var maxArray = extremes.max;\n                        var newVal;\n                        var k;\n\n                        for(k = 0; k < minArray.length; k++) {\n                            newVal = minArray[k].val - getPadMin(minArray[k]) / m;\n                            if(newVal > outerMin && newVal < rangeMin) {\n                                rangeMin = newVal;\n                            }\n                        }\n\n                        for(k = 0; k < maxArray.length; k++) {\n                            newVal = maxArray[k].val + getPadMax(maxArray[k]) / m;\n                            if(newVal < outerMax && newVal > rangeMax) {\n                                rangeMax = newVal;\n                            }\n                        }\n\n                        var domainExpand = (rangeMax - rangeMin) / (2 * halfRange);\n                        factor /= domainExpand;\n\n                        rangeMin = ax.l2r(rangeMin);\n                        rangeMax = ax.l2r(rangeMax);\n                        ax.range = ax._input.range = (rl0 < rl1) ?\n                            [rangeMin, rangeMax] : [rangeMax, rangeMin];\n                    }\n\n                    updateDomain(ax, factor);\n                }\n            }\n        }\n    }\n};\n\nexports.getAxisGroup = function getAxisGroup(fullLayout, axId) {\n    var matchGroups = fullLayout._axisMatchGroups;\n\n    for(var i = 0; i < matchGroups.length; i++) {\n        var group = matchGroups[i];\n        if(group[axId]) return 'g' + i;\n    }\n    return axId;\n};\n\n// For use before autoranging, check if this axis was previously constrained\n// by domain but no longer is\nexports.clean = function clean(gd, ax) {\n    if(ax._inputDomain) {\n        var isConstrained = false;\n        var axId = ax._id;\n        var constraintGroups = gd._fullLayout._axisConstraintGroups;\n        for(var j = 0; j < constraintGroups.length; j++) {\n            if(constraintGroups[j][axId]) {\n                isConstrained = true;\n                break;\n            }\n        }\n        if(!isConstrained || ax.constrain !== 'domain') {\n            ax._input.domain = ax.domain = ax._inputDomain;\n            delete ax._inputDomain;\n        }\n    }\n};\n\nfunction updateDomain(ax, factor) {\n    var inputDomain = ax._inputDomain;\n    var centerFraction = FROM_BL[ax.constraintoward];\n    var center = inputDomain[0] + (inputDomain[1] - inputDomain[0]) * centerFraction;\n\n    ax.domain = ax._input.domain = [\n        center + (inputDomain[0] - center) / factor,\n        center + (inputDomain[1] - center) / factor\n    ];\n    ax.setScale();\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}