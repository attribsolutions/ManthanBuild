{"ast":null,"code":"/* eslint block-scoped-var: 0*/\n\n/* eslint no-redeclare: 0*/\n'use strict';\n\nmodule.exports = computeTickMarks;\n\nvar Axes = require('../../cartesian/axes');\n\nvar Lib = require('../../../lib');\n\nvar AXES_NAMES = ['xaxis', 'yaxis', 'zaxis'];\nvar centerPoint = [0, 0, 0];\n\nfunction contourLevelsFromTicks(ticks) {\n  var result = new Array(3);\n\n  for (var i = 0; i < 3; ++i) {\n    var tlevel = ticks[i];\n    var clevel = new Array(tlevel.length);\n\n    for (var j = 0; j < tlevel.length; ++j) {\n      clevel[j] = tlevel[j].x;\n    }\n\n    result[i] = clevel;\n  }\n\n  return result;\n}\n\nfunction computeTickMarks(scene) {\n  var axesOptions = scene.axesOptions;\n  var glRange = scene.glplot.axesPixels;\n  var sceneLayout = scene.fullSceneLayout;\n  var ticks = [[], [], []];\n\n  for (var i = 0; i < 3; ++i) {\n    var axes = sceneLayout[AXES_NAMES[i]];\n    axes._length = (glRange[i].hi - glRange[i].lo) * glRange[i].pixelsPerDataUnit / scene.dataScale[i];\n\n    if (Math.abs(axes._length) === Infinity || isNaN(axes._length)) {\n      ticks[i] = [];\n    } else {\n      axes._input_range = axes.range.slice();\n      axes.range[0] = glRange[i].lo / scene.dataScale[i];\n      axes.range[1] = glRange[i].hi / scene.dataScale[i];\n      axes._m = 1.0 / (scene.dataScale[i] * glRange[i].pixelsPerDataUnit);\n\n      if (axes.range[0] === axes.range[1]) {\n        axes.range[0] -= 1;\n        axes.range[1] += 1;\n      } // this is necessary to short-circuit the 'y' handling\n      // in autotick part of calcTicks... Treating all axes as 'y' in this case\n      // running the autoticks here, then setting\n      // autoticks to false to get around the 2D handling in calcTicks.\n\n\n      var tickModeCached = axes.tickmode;\n\n      if (axes.tickmode === 'auto') {\n        axes.tickmode = 'linear';\n        var nticks = axes.nticks || Lib.constrain(axes._length / 40, 4, 9);\n        Axes.autoTicks(axes, Math.abs(axes.range[1] - axes.range[0]) / nticks);\n      }\n\n      var dataTicks = Axes.calcTicks(axes, {\n        msUTC: true\n      });\n\n      for (var j = 0; j < dataTicks.length; ++j) {\n        dataTicks[j].x = dataTicks[j].x * scene.dataScale[i];\n\n        if (axes.type === 'date') {\n          dataTicks[j].text = dataTicks[j].text.replace(/\\<br\\>/g, ' ');\n        }\n      }\n\n      ticks[i] = dataTicks;\n      axes.tickmode = tickModeCached;\n    }\n  }\n\n  axesOptions.ticks = ticks; // Calculate tick lengths dynamically\n\n  for (var i = 0; i < 3; ++i) {\n    centerPoint[i] = 0.5 * (scene.glplot.bounds[0][i] + scene.glplot.bounds[1][i]);\n\n    for (var j = 0; j < 2; ++j) {\n      axesOptions.bounds[j][i] = scene.glplot.bounds[j][i];\n    }\n  }\n\n  scene.contourLevels = contourLevelsFromTicks(ticks);\n}","map":{"version":3,"names":["module","exports","computeTickMarks","Axes","require","Lib","AXES_NAMES","centerPoint","contourLevelsFromTicks","ticks","result","Array","i","tlevel","clevel","length","j","x","scene","axesOptions","glRange","glplot","axesPixels","sceneLayout","fullSceneLayout","axes","_length","hi","lo","pixelsPerDataUnit","dataScale","Math","abs","Infinity","isNaN","_input_range","range","slice","_m","tickModeCached","tickmode","nticks","constrain","autoTicks","dataTicks","calcTicks","msUTC","type","text","replace","bounds","contourLevels"],"sources":["D:/Rohit/Git projects/Manthan/node_modules/plotly.js/src/plots/gl3d/layout/tick_marks.js"],"sourcesContent":["/* eslint block-scoped-var: 0*/\n/* eslint no-redeclare: 0*/\n\n'use strict';\n\nmodule.exports = computeTickMarks;\n\nvar Axes = require('../../cartesian/axes');\nvar Lib = require('../../../lib');\n\nvar AXES_NAMES = ['xaxis', 'yaxis', 'zaxis'];\n\nvar centerPoint = [0, 0, 0];\n\nfunction contourLevelsFromTicks(ticks) {\n    var result = new Array(3);\n    for(var i = 0; i < 3; ++i) {\n        var tlevel = ticks[i];\n        var clevel = new Array(tlevel.length);\n        for(var j = 0; j < tlevel.length; ++j) {\n            clevel[j] = tlevel[j].x;\n        }\n        result[i] = clevel;\n    }\n    return result;\n}\n\nfunction computeTickMarks(scene) {\n    var axesOptions = scene.axesOptions;\n    var glRange = scene.glplot.axesPixels;\n    var sceneLayout = scene.fullSceneLayout;\n\n    var ticks = [[], [], []];\n\n    for(var i = 0; i < 3; ++i) {\n        var axes = sceneLayout[AXES_NAMES[i]];\n\n        axes._length = (glRange[i].hi - glRange[i].lo) *\n            glRange[i].pixelsPerDataUnit / scene.dataScale[i];\n\n        if(Math.abs(axes._length) === Infinity ||\n           isNaN(axes._length)) {\n            ticks[i] = [];\n        } else {\n            axes._input_range = axes.range.slice();\n            axes.range[0] = (glRange[i].lo) / scene.dataScale[i];\n            axes.range[1] = (glRange[i].hi) / scene.dataScale[i];\n            axes._m = 1.0 / (scene.dataScale[i] * glRange[i].pixelsPerDataUnit);\n\n            if(axes.range[0] === axes.range[1]) {\n                axes.range[0] -= 1;\n                axes.range[1] += 1;\n            }\n            // this is necessary to short-circuit the 'y' handling\n            // in autotick part of calcTicks... Treating all axes as 'y' in this case\n            // running the autoticks here, then setting\n            // autoticks to false to get around the 2D handling in calcTicks.\n            var tickModeCached = axes.tickmode;\n            if(axes.tickmode === 'auto') {\n                axes.tickmode = 'linear';\n                var nticks = axes.nticks || Lib.constrain((axes._length / 40), 4, 9);\n                Axes.autoTicks(axes, Math.abs(axes.range[1] - axes.range[0]) / nticks);\n            }\n            var dataTicks = Axes.calcTicks(axes, { msUTC: true });\n            for(var j = 0; j < dataTicks.length; ++j) {\n                dataTicks[j].x = dataTicks[j].x * scene.dataScale[i];\n\n                if(axes.type === 'date') {\n                    dataTicks[j].text =\n                    dataTicks[j].text.replace(/\\<br\\>/g, ' ');\n                }\n            }\n            ticks[i] = dataTicks;\n\n\n            axes.tickmode = tickModeCached;\n        }\n    }\n\n    axesOptions.ticks = ticks;\n\n    // Calculate tick lengths dynamically\n    for(var i = 0; i < 3; ++i) {\n        centerPoint[i] = 0.5 * (scene.glplot.bounds[0][i] + scene.glplot.bounds[1][i]);\n        for(var j = 0; j < 2; ++j) {\n            axesOptions.bounds[j][i] = scene.glplot.bounds[j][i];\n        }\n    }\n\n    scene.contourLevels = contourLevelsFromTicks(ticks);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}